<!DOCTYPE html><!--Original code: https://gitlab.com/OpenRGBDevelopers/OpenRGBEffectsPlugin/-/tree/master?ref_type=heads-->
<html>
<head>
    <title>Audio Bubbles</title>
    <meta description="Expanding bubbles of light are triggered by your audio.">
    <meta publisher="Jose Miranda (Port and improvements)">

    <meta property="trigger" label="Volume Trigger" type="number" min="1" max="100" default="30">
    <meta property="max_bubbles" label="Max Bubbles" type="number" min="1" max="32" default="8">
    <meta property="speed" label="Speed" type="number" min="1" max="1000" default="50">
    <meta property="max_expansion" label="Max Expansion" type="number" min="1" max="1000" default="100">
    <meta property="bubbles_thickness" label="Bubbles Thickness" type="number" min="1" max="200" default="10">
    <meta property="spawnMode" label="Bubbles Spawn" type="list" values="Random XY,Random X,Random Y,Center" default="Random XY">
    <meta property="preset" label="Color Preset" type="list" values="Unicorn Vomit,Borealis,Ocean,Pink/Blue,Pink/Gold,Pulse,Purple/Orange,LightBlue/Purple,Police Beacon,Seabed,Sunset,Vaporwave" default="Unicorn Vomit">
</head>

<body style="margin: 0; padding: 0;">
    <canvas id="audiobubbles-canvas" width="320" height="200"></canvas>
</body>

<script>
// -------------------------------------------------------------------
// SETUP
// -------------------------------------------------------------------

const canvas = document.getElementById('audiobubbles-canvas');
const ctx = canvas.getContext('2d');
const canvasWidth = canvas.width;
const canvasHeight = canvas.height;
const imageData = ctx.createImageData(canvasWidth, canvasHeight);
const pixels = imageData.data;

const gradientCanvas = document.createElement('canvas');
gradientCanvas.width = 200;
gradientCanvas.height = 1;
const gradientCtx = gradientCanvas.getContext('2d', { willReadFrequently: true });

let bubbles = [];
let gradientData = null;
let lastPreset = "";

const presets = {
    "Unicorn Vomit": ["#ff0000","#ff00e6","#0000ff","#00b3ff","#00ff51","#eaff00","#ffb300","#ff0000"],
    "Borealis": ["#14e81e","#00ea8d","#017ed5","#b53dff","#8d00c4","#14e81e"],
    "Ocean": ["#00007f","#0000ff","#00ffff","#00aaff","#00007f"],
    "Pink/Blue": ["#fe00c5","#00c5ff","#00c5ff","#fe00c5"],
    "Pink/Gold": ["#fee000","#fe00fe","#fe00fe","#fee000"],
    "Pulse": ["#ff5500","#000000","#000000","#000000","#ff5500"],
    "Purple/Orange": ["#ff2100","#aa00ff","#aa00ff","#ff2100","#ff2100","#ff2100"],
    "LightBlue/Purple": ["#03fffa","#55007f","#55007f","#03fffa"],
    "Police Beacon": ["#ff0000","#0000ff","#0000ff","#ff0000","#ff0000"],
    "Seabed": ["#00ff00","#0032ff","#0032ff","#00ff00","#00ff00"],
    "Sunset": ["#ff2100","#ab006d","#c01c52","#d53737","#ea531b","#ff6e00","#ff0000","#ff2100"],
    "Vaporwave": ["#FF71CE","#B967FF","#01CDFE","#05FFA1","#FFFB96","#FF71CE"],
};

// -------------------------------------------------------------------
// COLOR UTILITIES & HELPERS
// -------------------------------------------------------------------

function screenBlend(destIndex, r, g, b) {
    const rDest = pixels[destIndex];
    const gDest = pixels[destIndex + 1];
    const bDest = pixels[destIndex + 2];
    
    pixels[destIndex]     = 255 - ((255 - rDest) * (255 - r) >> 8);
    pixels[destIndex + 1] = 255 - ((255 - gDest) * (255 - g) >> 8);
    pixels[destIndex + 2] = 255 - ((255 - bDest) * (255 - b) >> 8);
}

function generateGradient(presetName) {
    const colors = presets[presetName];
    if (!colors) return;

    const grad = gradientCtx.createLinearGradient(0, 0, gradientCanvas.width, 0);
    const step = 1.0 / (colors.length - 1);
    for (let i = 0; i < colors.length; i++) {
        grad.addColorStop(i * step, colors[i]);
    }

    gradientCtx.fillStyle = grad;
    gradientCtx.fillRect(0, 0, gradientCanvas.width, 1);
    gradientData = gradientCtx.getImageData(0, 0, gradientCanvas.width, 1).data;
}

// -------------------------------------------------------------------
// BUBBLE LOGIC
// -------------------------------------------------------------------

function triggerBubbles(audioData) {
    const triggerValue = trigger / 100.0;
    const occupiedFrequencies = new Set(bubbles.map(b => b.freq_id));
    
    const activeFrequencies = [];
    let minFreq = 200;
    let maxFreq = 0;

    // First, find all frequencies above the threshold and determine the active range.
    for (let i = 0; i < audioData.length; i++) {
        const amp = Math.abs(audioData[i]) / 128.0;
        if (amp >= triggerValue && !occupiedFrequencies.has(i)) {
            activeFrequencies.push({ amp: amp, freq_id: i });
            if (i < minFreq) minFreq = i;
            if (i > maxFreq) maxFreq = i;
        }
    }
    
    // Create new bubbles from the highest amplitude frequencies within the active range.
    activeFrequencies.sort((a, b) => b.amp - a.amp);
    
    for (const candidate of activeFrequencies) {
        if (bubbles.length >= max_bubbles) {
            break;
        }
        
        const amp = Math.max(0.2, Math.min(0.8, candidate.amp));
        let center = { x: 0.5, y: 0.5 };
        
        // Dynamically map the frequency ID to a position on the gradient.
        let mappedFreq = candidate.freq_id;
        if (maxFreq > minFreq) {
            mappedFreq = Math.floor(((candidate.freq_id - minFreq) / (maxFreq - minFreq)) * (gradientCanvas.width - 1));
        } else {
            // If only one frequency is active, map it to the middle of the gradient.
            mappedFreq = Math.floor(gradientCanvas.width / 2);
        }

        switch(spawnMode) {
            case "Random XY": center = { x: Math.random(), y: Math.random() }; break;
            case "Random X": center = { x: Math.random(), y: 1.0 - (mappedFreq / gradientCanvas.width) }; break;
            case "Random Y": center = { x: mappedFreq / gradientCanvas.width, y: Math.random() }; break;
            case "Center": break;
        }

        bubbles.push({
            amp: amp, center: center, progress: 0,
            speed: 1.0 / amp, freq_id: mappedFreq
        });
        occupiedFrequencies.add(candidate.freq_id);
    }
}

function expandBubbles(deltaTime) {
    const speedFactor = 0.1 * (speed / 10) * deltaTime * 60;
    for (const bubble of bubbles) {
        bubble.progress += speedFactor * bubble.speed;
    }
}

function cleanupBubbles() {
    bubbles = bubbles.filter(bubble => bubble.progress < (max_expansion * bubble.amp));
}

// -------------------------------------------------------------------
// MAIN ANIMATION LOOP
// -------------------------------------------------------------------

let lastTime = 0;

function update(currentTime) {
    const deltaTime = (currentTime - lastTime) / 1000;
    lastTime = currentTime;

    if (isNaN(deltaTime)) {
        requestAnimationFrame(update);
        return;
    }
    
    if (preset !== lastPreset) {
        generateGradient(preset);
        lastPreset = preset;
    }

    if (!gradientData) {
        requestAnimationFrame(update);
        return;
    }
    
    const audioData = new Int8Array(engine.audio.freq);

    expandBubbles(deltaTime);
    triggerBubbles(audioData);
    cleanupBubbles();

    // Clear the pixel data for this frame
    for (let i = 0; i < pixels.length; i += 4) {
        pixels[i] = 0;
        pixels[i + 1] = 0;
        pixels[i + 2] = 0;
        pixels[i + 3] = 255;
    }

    // Optimized drawing loop: Iterate through bubbles and apply their color to the pixels
    for (const bubble of bubbles) {
        const cx = canvasWidth * bubble.center.x;
        const cy = canvasHeight * bubble.center.y;
        
        const bubbleR = bubble.progress;
        const bubbleThickness = 0.1 * bubbles_thickness * bubble.amp;

        const progress_norm = Math.min(1, bubbleR / (max_expansion * bubble.amp));
        const brightnessFactor = Math.pow(1.0 - progress_norm, 0.5);

        const gradIndex = bubble.freq_id * 4;
        const r_base = gradientData[gradIndex];
        const g_base = gradientData[gradIndex + 1];
        const b_base = gradientData[gradIndex + 2];
        
        // Iterate through all pixels and apply the bubble effect
        for (let y = 0; y < canvasHeight; y++) {
            for (let x = 0; x < canvasWidth; x++) {
                const distance = Math.sqrt(Math.pow(cx - x, 2) + Math.pow(cy - y, 2));
                const shallow = Math.abs(distance - bubbleR) / bubbleThickness;
                const value = Math.min(255, 255 * (1 / Math.pow(shallow, 3)));
                
                if (value > 1) {
                    const brightness = value * brightnessFactor;
                    const r = Math.round(r_base * (brightness / 255));
                    const g = Math.round(g_base * (brightness / 255));
                    const b = Math.round(b_base * (brightness / 255));
                    
                    const pixelIndex = (y * canvasWidth + x) * 4;
                    screenBlend(pixelIndex, r, g, b);
                }
            }
        }
    }

    // Put the final pixel data to the canvas in one go
    ctx.putImageData(imageData, 0, 0);
    
    requestAnimationFrame(update);
}

// Initial call
generateGradient("Unicorn Vomit");
requestAnimationFrame(update);

</script>
</html>