<!DOCTYPE html>
<html>

<head>
    <title>Audio Party</title>
    <meta description="Movement, color change, and effects driven by audio frequency zones.">
    <meta publisher="Jose Miranda (Conversion and improvements)">

    <meta property="speed" label="Motion Speed" type="number" min="1" max="100" default="15">
    <meta property="color_change_speed" label="Color Change Speed" type="number" min="1" max="50" default="25">
    <meta property="rotation_speed" label="Rotation Speed" type="number" min="-100" max="100" default="0">
    <meta property="divisions" label="Divisions" type="number" min="2" max="16" step="2" default="2">
    <meta property="effect_threshold_percent" label="Effect Threshold (%)" type="number" min="0" max="100" step="1" default="5">
    <meta property="noise_mode" label="Noise Mode" type="combobox" default="Normal" values="Normal,Psychedelic">

    <meta property="noise_frequency_percent" label="Noise Frequency (%)" type="number" min="0" max="100" default="30">
    <meta property="noise_scale" label="Noise Scale" type="number" min="1" max="100" default="50">
    <meta property="noise_is_rgb" label="Color Noise" type="boolean" default="true">

    <meta property="enable_horizontal_bars" label="Enable Horizontal Bars" type="boolean" default="true">
    <meta property="enable_vertical_bars" label="Enable Vertical Bars" type="boolean" default="true">
    <meta property="enable_shockwave" label="Enable Shockwave" type="boolean" default="true">
    <meta property="enable_blink" label="Enable Blink/Explosion" type="boolean" default="true">
    <meta property="enable_glitch" label="Enable Glitch Effect" type="boolean" default="true">
    <meta property="shockwave_thickness" label="Shockwave Thickness" type="number" min="1" max="50" default="20">
    <meta property="shockwave_color" label="Shockwave Color" type="color" default="#ffffff">
    <meta property="glitch_intensity" label="Glitch Intensity" type="number" min="1" max="100" default="25">

    <meta property="motion_zone_stop" label="Motion Zone End" type="number" min="0" max="199" step="1" default="50">
    <meta property="color_zone_stop" label="Color Zone End" type="number" min="0" max="200" step="1" default="150">

    <meta property="psychedelic_preset" label="Psychedelic Preset" type="combobox" default="Medium" values="Soft,Medium,Intense">

</head>

<body style="margin: 0; padding: 0;">
    <canvas id="audioparty-canvas" width="320" height="200"></canvas>
</body>

<script>
    // -------------------------------------------------------------------
    // SETUP
    // -------------------------------------------------------------------

    const canvas = document.getElementById('audioparty-canvas');
    const ctx = canvas.getContext('2d');
    const canvasWidth = canvas.width;
    const canvasHeight = canvas.height;

    // Effect state variables
    let x_shift = 0.0;
    let color_shift = 0.0;
    let rotation_angle = 0.0;
    let effect_progress = 1.0;
    let effect_idx = 0;
    let other_effect_cycler = -1;
    let progress = 0.0;
    // Pre-allocate reused objects for better performance
    const imageData = ctx.createImageData(canvasWidth, canvasHeight);
    const data = imageData.data;
    
    // Cache trigonometric calculations
    let cachedCos = 1, cachedSin = 0;
    let lastRotationAngle = 0;



    // -------------------------------------------------------------------
    // COLOR UTILITIES
    // -------------------------------------------------------------------

    function hsvToRgb(h, s, v) {
        let r, g, b;
        const i = Math.floor(h * 6);
        const f = h * 6 - i;
        const p = v * (1 - s);
        const q = v * (1 - f * s);
        const t = v * (1 - (1 - f) * s);
        switch (i % 6) {
            case 0: r = v, g = t, b = p; break; case 1: r = q, g = v, b = p; break;
            case 2: r = p, g = v, b = t; break; case 3: r = p, g = q, b = v; break;
            case 4: r = t, g = p, b = v; break; case 5: r = v, g = p, b = q; break;
        }
        return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
    }

    function hexToRgb(hex) {
        if (!hex) return [255, 255, 255];
        const r = parseInt(hex.slice(1, 3), 16);
        const g = parseInt(hex.slice(3, 5), 16);
        const b = parseInt(hex.slice(5, 7), 16);
        return [r, g, b];
    }

    function screenBlend(base, blend) {
        const r = 1 - (1 - base[0] / 255) * (1 - blend[0] / 255);
        const g = 1 - (1 - base[1] / 255) * (1 - blend[1] / 255);
        const b = 1 - (1 - base[2] / 255) * (1 - blend[2] / 255);
        return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
    }

    function lerpColor(color1, color2, factor) {
        const r = color1[0] * (1 - factor) + color2[0] * factor;
        const g = color1[1] * (1 - factor) + color2[1] * factor;
        const b = color1[2] * (1 - factor) + color2[2] * factor;
        return [Math.round(r), Math.round(g), Math.round(b)];
    }

    // -------------------------------------------------------------------
    // EFFECT LOGIC
    // -------------------------------------------------------------------

    const seededRandom = s => {
        s = Math.sin(s) * 43758.5453;
        return s - Math.floor(s);
    };

    // -------------------------------------------------------------------
    // SIMPLEX NOISE ALGORITHM
    // -------------------------------------------------------------------
    const SimplexNoise = (function () {
        const F3 = 1.0 / 3.0, G3 = 1.0 / 6.0;
        const grad3 = new Float32Array([1, 1, 0, -1, 1, 0, 1, -1, 0, -1, -1, 0, 1, 0, 1, -1, 0, 1, 1, 0, -1, -1, 0, -1, 0, 1, 1, 0, -1, 1, 0, 1, -1, 0, -1, -1]);
        const p = new Uint8Array(256);
        for (let i = 0; i < 256; i++) p[i] = i;
        for (let i = 255; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1));[p[i], p[j]] = [p[j], p[i]]; }
        const perm = new Uint8Array(512);
        const permMod12 = new Uint8Array(512);
        for (let i = 0; i < 512; i++) { perm[i] = p[i & 255]; permMod12[i] = perm[i] % 12; }

        return {
            noise3D: function (xin, yin, zin) {
                let n0, n1, n2, n3;
                const s = (xin + yin + zin) * F3;
                const i = Math.floor(xin + s), j = Math.floor(yin + s), k = Math.floor(zin + s);
                const t = (i + j + k) * G3;
                const X0 = i - t, Y0 = j - t, Z0 = k - t;
                const x0 = xin - X0, y0 = yin - Y0, z0 = zin - Z0;
                let i1, j1, k1, i2, j2, k2;
                if (x0 >= y0) {
                    if (y0 >= z0) { i1 = 1; j1 = 0; k1 = 0; i2 = 1; j2 = 1; k2 = 0; }
                    else if (x0 >= z0) { i1 = 1; j1 = 0; k1 = 0; i2 = 1; j2 = 0; k2 = 1; }
                    else { i1 = 0; j1 = 0; k1 = 1; i2 = 1; j2 = 0; k2 = 1; }
                } else {
                    if (y0 < z0) { i1 = 0; j1 = 0; k1 = 1; i2 = 0; j2 = 1; k2 = 1; }
                    else if (x0 < z0) { i1 = 0; j1 = 1; k1 = 0; i2 = 0; j2 = 1; k2 = 1; }
                    else { i1 = 0; j1 = 1; k1 = 0; i2 = 1; j2 = 1; k2 = 0; }
                }
                const x1 = x0 - i1 + G3, y1 = y0 - j1 + G3, z1 = z0 - k1 + G3;
                const x2 = x0 - i2 + 2.0 * G3, y2 = y0 - j2 + 2.0 * G3, z2 = z0 - k2 + 2.0 * G3;
                const x3 = x0 - 1.0 + 3.0 * G3, y3 = y0 - 1.0 + 3.0 * G3, z3 = z0 - 1.0 + 3.0 * G3;
                const ii = i & 255, jj = j & 255, kk = k & 255;
                const gi0 = permMod12[ii + perm[jj + perm[kk]]];
                const gi1 = permMod12[ii + i1 + perm[jj + j1 + perm[kk + k1]]];
                const gi2 = permMod12[ii + i2 + perm[jj + j2 + perm[kk + k2]]];
                const gi3 = permMod12[ii + 1 + perm[jj + 1 + perm[kk + 1]]];
                let t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0;
                if (t0 < 0) n0 = 0.0;
                else { t0 *= t0; n0 = t0 * t0 * (grad3[gi0] * x0 + grad3[gi0 + 1] * y0 + grad3[gi0 + 2] * z0); }
                let t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1;
                if (t1 < 0) n1 = 0.0;
                else { t1 *= t1; n1 = t1 * t1 * (grad3[gi1] * x1 + grad3[gi1 + 1] * y1 + grad3[gi1 + 2] * z1); }
                let t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2;
                if (t2 < 0) n2 = 0.0;
                else { t2 *= t2; n2 = t2 * t2 * (grad3[gi2] * x2 + grad3[gi2 + 2] * y2 + grad3[gi2 + 2] * z2); }
                let t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3;
                if (t3 < 0) n3 = 0.0;
                else { t3 *= t3; n3 = t3 * t3 * (grad3[gi3] * x3 + grad3[gi3 + 1] * y3 + grad3[gi3 + 2] * z3); }
                return 32.0 * (n0 + n1 + n2 + n3);
            },
            fractal: function (octaves, x, y, z, freq, amp, lac, per) {
                let val = 0;
                for (let i = 0; i < octaves; i++) {
                    val += this.noise3D(x * freq, y * freq, z * freq) * amp;
                    freq *= lac;
                    amp *= per;
                }
                return val;
            }
        };
    })();

    function getColor(x, y, w, h, params) {
        const {
            cos_a, sin_a, divisions, x_shift, color_shift,
            effect_progress, effect_idx, glitch_intensity, noise_scale, noise_is_rgb,
            shockwave_thickness, shockwave_color,
            frequency, amplitude, lacunarity, persistence, octaves, progress
        } = params;

        const centerX = w * 0.5; // Use multiplication instead of division
        const centerY = h * 0.5;
        const translatedX = x - centerX;
        const translatedY = y - centerY;

        const rotatedX = translatedX * cos_a - translatedY * sin_a;
        const rotatedY = translatedX * sin_a + translatedY * cos_a;

        let finalX = rotatedX + centerX;
        let finalY = rotatedY + centerY;

        if (effect_progress < 1 && effect_idx === 7) {
            const line_seed = y * 1234.5;
            const random_offset = (seededRandom(line_seed) - 0.5) * 2;
            const intensity_factor = (glitch_intensity * 0.01) * w * 0.2; // Pre-calculate division
            const current_intensity = intensity_factor * (1 - effect_progress);
            finalX += random_offset * current_intensity;
        }

        // Calculate the wave intensity (how much color should be visible)
        const s = 0.5 * (1 + Math.sin((finalX * divisions * Math.PI) / w + x_shift)); // Rearrange division
        const hue = (180 + Math.sin(finalY / h + color_shift) * 180) / 360;
        
        // Pre-calculate HSV to RGB conversion values
        const hue6 = hue * 6;
        const i = Math.floor(hue6);
        const f = hue6 - i;
        const p = 1 - 1; // v=1, s=1, so p = v * (1-s) = 0
        const q = 1 - f;
        const t = f;
        
        let r, g, b;
        switch (i % 6) {
            case 0: r = 1; g = t; b = 0; break;
            case 1: r = q; g = 1; b = 0; break;
            case 2: r = 0; g = 1; b = t; break;
            case 3: r = 0; g = q; b = 1; break;
            case 4: r = t; g = 0; b = 1; break;
            case 5: r = 1; g = 0; b = q; break;
        }
        const waveColor = [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];

        let baseColor = [0, 0, 0]; // Start with black background
        
        // Only apply noise if there's wave intensity AND noise effect is active AND noise is enabled
        if (s > 0.001 && effect_progress < 1 && (effect_idx === 4 || effect_idx === 8) && noise_is_rgb) {
            let noiseColor = [0, 0, 0];
            
            if (effect_idx === 4) { // Regular Pixel Noise
                const blockSize = 1 + Math.floor(noise_scale / 40);
                const blockX = Math.floor((finalX + x_shift * w) / blockSize);
                const blockY = Math.floor((finalY + color_shift * h) / blockSize);
                const seed = (blockX * 16807 + blockY * 37) & 0x7fffffff;
                if (noise_is_rgb) {
                    noiseColor = [Math.floor(seededRandom(seed) * 255), Math.floor(seededRandom(seed * 1.3) * 255), Math.floor(seededRandom(seed * 1.7) * 255)];
                } else {
                    const val = Math.floor(seededRandom(seed) * 255);
                    noiseColor = [val, val, val];
                }
            } else if (effect_idx === 8) { // Psychedelic Noise
                const maxFrequency = 5000;
                const minFrequency = 50;
                const reversedScale = 100 - noise_scale;
                const psychedelicFrequency = minFrequency + (reversedScale / 100) * (maxFrequency - minFrequency);
                const noiseVal = SimplexNoise.fractal(2, finalX / w, finalY / h, progress, psychedelicFrequency / 10000, 39000 / 10000, 7500 / 10000, 5000 / 10000);
                const frac = (1 + Math.abs(noiseVal)) * 0.5;
                const noiseHue = 360 * frac;
                noiseColor = hsvToRgb(noiseHue / 360, 1, 1);
            }
            
            // Blend noise with wave color based on wave intensity
            // First blend noise as the base, then blend wave color on top
            const blendedNoiseWave = screenBlend(noiseColor, waveColor);
            baseColor = lerpColor(baseColor, blendedNoiseWave, s);
        } else {
            // No noise effect active - just use normal wave blending
            baseColor = lerpColor(baseColor, waveColor, s);
        }

        let finalColor = baseColor;

        // Apply other effects on top
        if (effect_progress < 1) {
            let effectColor = [0, 0, 0];
            switch (effect_idx) {
                case 0: case 1: case 2: case 3:
                    const bar_width = 2;
                    if ((effect_idx <= 1 && Math.abs(finalX - (effect_idx === 0 ? effect_progress * w : w - effect_progress * w)) <= bar_width) ||
                        (effect_idx >= 2 && Math.abs(finalY - (effect_idx === 2 ? effect_progress * h : h - effect_progress * h)) <= bar_width)) {
                        effectColor = [255, 255, 255];
                    }
                    break;
                case 5:
                    effectColor = [255, 255, 255].map(c => c * (1 - effect_progress));
                    break;
                case 6:
                    const dist = Math.sqrt(translatedX * translatedX + translatedY * translatedY);
                    if (Math.abs(dist - (effect_progress * w / 2)) < shockwave_thickness) {
                        effectColor = hexToRgb(shockwave_color);
                    }
                    break;
            }
            finalColor = screenBlend(finalColor, effectColor);
        }

        return finalColor;
    }

    // -------------------------------------------------------------------
    // MAIN ANIMATION LOOP
    // -------------------------------------------------------------------

    let lastTime = 0;
    function update(currentTime) {
        const deltaTime = (currentTime - lastTime) / 1000;
        lastTime = currentTime;

        if (isNaN(deltaTime)) { window.requestAnimationFrame(update); return; }

        // Set psychedelic noise properties based on the preset
        switch (psychedelic_preset) {
            case "Soft":
                psychedelic_frequency = 500;
                psychedelic_amplitude = 10000;
                psychedelic_lacunarity = 1000;
                psychedelic_persistence = 1000;
                psychedelic_octaves = 1;
                break;
            case "Medium":
                psychedelic_frequency = 1200;
                psychedelic_amplitude = 39000;
                psychedelic_lacunarity = 7500;
                psychedelic_persistence = 5000;
                psychedelic_octaves = 2;
                break;
            case "Intense":
                psychedelic_frequency = 3000;
                psychedelic_amplitude = 50000;
                psychedelic_lacunarity = 10000;
                psychedelic_persistence = 8000;
                psychedelic_octaves = 3;
                break;
            default:
                psychedelic_frequency = 1200;
                psychedelic_amplitude = 39000;
                psychedelic_lacunarity = 7500;
                psychedelic_persistence = 5000;
                psychedelic_octaves = 2;
                break;
        }

        const audioData = new Int8Array(engine.audio.freq);
        const effect_threshold = effect_threshold_percent / 100.0;
        const motionDelta = speed * deltaTime;
        const colorDelta = color_change_speed * deltaTime;

        rotation_angle += (rotation_speed / 100) * 90 * deltaTime;
        progress += 0.1 * speed * deltaTime;

        for (let i = 0; i < motion_zone_stop; i++) {
            if (audioData[i] > audioData[i + 1]) {
                x_shift += (audioData[i] / 128.0) * motionDelta * ((i % 2 === 0) ? 1 : -1);
                break;
            }
        }
        for (let i = motion_zone_stop; i < color_zone_stop; i++) {
            if (audioData[i] > audioData[i + 1]) {
                color_shift += (audioData[i] / 128.0) * colorDelta * ((i % 2 === 0) ? 1 : -1);
                break;
            }
        }

        if (effect_progress >= 1) {
            let maxLevel = 0;
            for (let i = color_zone_stop; i < 200; i++) {
                const level = Math.abs(audioData[i]) / 128.0;
                if (level > maxLevel) maxLevel = level;
            }

            if (maxLevel > effect_threshold) {
                const availableEffects = [];
                if (enable_horizontal_bars) { availableEffects.push(0, 1); }
                if (enable_vertical_bars) { availableEffects.push(2, 3); }
                if (enable_shockwave) { availableEffects.push(6); }
                if (enable_blink) { availableEffects.push(5); }
                if (enable_glitch) { availableEffects.push(7); }

                if (noise_mode === "Normal") {
                    availableEffects.push(4);
                } else if (noise_mode === "Psychedelic") {
                    availableEffects.push(8);
                }

                if (availableEffects.length > 0) {
                    other_effect_cycler = (other_effect_cycler + 1) % availableEffects.length;
                    effect_idx = availableEffects[other_effect_cycler];
                    effect_progress = 0;
                }
            }
        }

        if (effect_progress < 1) {
            // Make noise effects progress faster than other effects
            if (effect_idx === 4 || effect_idx === 8) {
                effect_progress += 1.5 * deltaTime; // Faster progression for noise
            } else {
                effect_progress += 0.5 * deltaTime;
            }
        } else {
            effect_progress = 1.0;
        }

        // Cache trigonometric calculations
        if (rotation_angle !== lastRotationAngle) {
            const angle_rad = rotation_angle * Math.PI / 180.0;
            cachedCos = Math.cos(angle_rad);
            cachedSin = Math.sin(angle_rad);
            lastRotationAngle = rotation_angle;
        }

        const params = {
            rotation_angle,
            cos_a: cachedCos,
            sin_a: cachedSin,
            divisions,
            x_shift,
            color_shift,
            effect_progress,
            effect_idx,
            glitch_intensity,
            noise_scale,
            noise_is_rgb,
            shockwave_thickness,
            shockwave_color,
            enable_horizontal_bars,
            enable_vertical_bars,
            frequency: psychedelic_frequency,
            amplitude: psychedelic_amplitude,
            lacunarity: psychedelic_lacunarity,
            persistence: psychedelic_persistence,
            octaves: psychedelic_octaves,
            progress
        };

        // Reuse the pre-allocated imageData instead of creating new one
        let idx = 0;
        for (let y = 0; y < canvasHeight; y++) {
            for (let x = 0; x < canvasWidth; x++) {
                const rgb = getColor(x, y, canvasWidth, canvasHeight, params);
                data[idx++] = rgb[0];
                data[idx++] = rgb[1];
                data[idx++] = rgb[2];
                data[idx++] = 255;
            }
        }
        ctx.putImageData(imageData, 0, 0);

        window.requestAnimationFrame(update);
    }

    window.requestAnimationFrame(update);

</script>

</html>