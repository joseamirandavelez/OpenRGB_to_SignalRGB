<!DOCTYPE html>
<html>
<head>
    <title>Audio Sync</title>
    <meta description="Display frequency based colors with different modes.">
    <meta publisher="Jose Miranda (Conversion and improvements)">

    <meta property="sensitivity" label="Sensitivity" type="number" min="1" max="500" default="100">
    <meta property="hue_shift" label="Hue Shift" type="number" min="0" max="360" default="0">
    <meta property="color_fade_speed" label="Color Fade Speed" type="number" min="1" max="99" default="50">
    <meta property="saturation" label="Saturation" type="list" values="Normal,Saturate High Amplitudes,Black & White" default="Normal">
    <meta property="roll_mode" label="Roll Mode" type="list" values="Linear Horizontal,No Roll,Radial,Wave,Linear Vertical" default="Linear Horizontal">
    
    <meta property="bypass_min" label="Band-pass Min Freq" type="number" min="0" max="199" default="0">
    <meta property="bypass_max" label="Band-pass Max Freq" type="number" min="0" max="200" default="200">

    <meta property="silent_color_enable" label="Enable Silent Color" type="boolean" default="false">
    <meta property="silent_color_value" label="Silent Color" type="color" default="#000000">
</head>

<body style="margin: 0; padding: 0;">
    <canvas id="audiosync-canvas" width="320" height="200"></canvas>
</body>

<script>
// -------------------------------------------------------------------
// SETUP
// -------------------------------------------------------------------

const canvas = document.getElementById('audiosync-canvas');
const ctx = canvas.getContext('2d');
const canvasWidth = canvas.width;
const canvasHeight = canvas.height;

// Effect state variables
let immediate_freq_hue = 0;
let current_freq_hue = 0;
let current_freq_sat = 255;
let current_freq_val = 0;
let colors_rotation = [];
let silent_color_timer = 0;
const SILENT_COLOR_TIMEOUT = 120; // frames

const rainbow_hues = [];
for (let i = 0; i < 200; i++) {
    rainbow_hues.push(360 - (i / 199.0) * 360);
}

// -------------------------------------------------------------------
// COLOR UTILITIES
// -------------------------------------------------------------------

function hsvToRgb(h, s, v) {
    let r, g, b;
    h /= 360; s /= 255; v /= 255;
    const i = Math.floor(h * 6);
    const f = h * 6 - i;
    const p = v * (1 - s);
    const q = v * (1 - f * s);
    const t = v * (1 - (1 - f) * s);
    switch (i % 6) {
        case 0: r = v, g = t, b = p; break; case 1: r = q, g = v, b = p; break;
        case 2: r = p, g = v, b = t; break; case 3: r = p, g = q, b = v; break;
        case 4: r = t, g = p, b = v; break; case 5: r = v, g = p, b = q; break;
    }
    return [r * 255, g * 255, b * 255];
}

function hexToRgb(hex) {
    if (!hex) return [0, 0, 0];
    const r = parseInt(hex.slice(1, 3), 16);
    const g = parseInt(hex.slice(3, 5), 16);
    const b = parseInt(hex.slice(5, 7), 16);
    return [r, g, b];
}

// -------------------------------------------------------------------
// EFFECT LOGIC
// -------------------------------------------------------------------

function getColor(x, y, w, h) {
    let color = [0, 0, 0];
    // We must read the property inside this function if it's used here
    const current_roll_mode = engine.getProperty('roll_mode') || "Linear Horizontal";
    const index = getRollIndex(x, y, w, h, current_roll_mode);
    if (index < colors_rotation.length) {
        color = colors_rotation[index];
    }
    return `rgb(${Math.round(color[0])}, ${Math.round(color[1])}, ${Math.round(color[2])})`;
}

function getRollIndex(x, y, w, h, roll_mode_val) {
    switch (roll_mode_val) {
        case "Linear Horizontal": return x;
        case "No Roll": return 0;
        case "Radial": {
            const centerX = w / 2;
            const centerY = h / 2;
            return Math.round(Math.sqrt(Math.pow(centerX - x, 2) + Math.pow(centerY - y, 2)));
        }
        case "Wave": {
            const centerX = w * 1.1;
            const centerY = h / 2;
            return Math.round(Math.sqrt(Math.pow(centerX - x, 2) + Math.pow(centerY - y, 2)));
        }
        case "Linear Vertical": return y;
    }
    return 0;
}

// -------------------------------------------------------------------
// MAIN ANIMATION LOOP
// -------------------------------------------------------------------

let lastTime = 0;
function update(currentTime) {
    const deltaTime = (currentTime - lastTime) / 1000;
    lastTime = currentTime;

    // FIXED: This is a more robust check that waits for the audio, UI properties, and canvas to all be ready.
    if (isNaN(deltaTime) || typeof engine === 'undefined' || !engine.audio || !engine.audio.freq || !engine.properties) {
        requestAnimationFrame(update);
        return;
    }

    const {
        sensitivity = 100, hue_shift = 0, color_fade_speed = 50,
        saturation = "Normal", bypass_min = 0, bypass_max = 200,
        silent_color_enable = false, silent_color_value = "#000000"
    } = engine.properties;

    const audioData = new Int8Array(engine.audio.freq);
    const fps = deltaTime > 0 ? 1 / deltaTime : 60;
    
    let max_idx = -1;
    let max_value = 0;
    const min_freq = Math.max(0, bypass_min);
    const max_freq = Math.min(200, bypass_max);
    
    const sensitivity_mult = sensitivity / 100.0;

    for (let i = min_freq; i < max_freq; i++) {
        const amp = (Math.abs(audioData[i]) / 128.0) * sensitivity_mult;
        if (amp > max_value) {
            max_value = amp;
            max_idx = i;
        }
    }

    if (max_idx !== -1) {
        const shifted_idx = (max_idx + hue_shift) % 200;
        immediate_freq_hue = rainbow_hues[shifted_idx];
        
        const fadeFactor = 1.0 - (color_fade_speed / 100.0);
        const diff = immediate_freq_hue - current_freq_hue;
        current_freq_hue += (diff / (fadeFactor * 10 + 1)) / (fps / 60);

        switch(saturation) {
            case "Saturate High Amplitudes":
                current_freq_sat = 255 - 255 * Math.pow(max_value, 3);
                break;
            case "Black & White":
                current_freq_sat = 0;
                break;
            default:
                current_freq_sat = 255;
                break;
        }
        current_freq_val = max_value * 255;
    } else {
        current_freq_val -= 5.0;
    }
    
    current_freq_sat = Math.max(0, Math.min(255, current_freq_sat));
    current_freq_val = Math.max(0, Math.min(255, current_freq_val));

    let mainColor = hsvToRgb(current_freq_hue, current_freq_sat, current_freq_val);

    if (current_freq_val < 1 && silent_color_enable) {
        silent_color_timer = Math.min(SILENT_COLOR_TIMEOUT, silent_color_timer + 1);
        const silentRgb = hexToRgb(silent_color_value);
        const brightness = silent_color_timer / SILENT_COLOR_TIMEOUT;
        mainColor = [silentRgb[0] * brightness, silentRgb[1] * brightness, silentRgb[2] * brightness];
    } else {
        silent_color_timer = 0;
    }
    
    colors_rotation.unshift(mainColor);
    if (colors_rotation.length > 1024) {
        colors_rotation.pop();
    }
    
    for (let y = 0; y < canvasHeight; y++) {
        for (let x = 0; x < canvasWidth; x++) {
            ctx.fillStyle = getColor(x, y, canvasWidth, canvasHeight);
            ctx.fillRect(x, y, 1, 1);
        }
    }
    
    requestAnimationFrame(update);
}

// Initial call
requestAnimationFrame(update);

</script>
</html>