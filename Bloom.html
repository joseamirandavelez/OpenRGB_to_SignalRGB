<!DOCTYPE html><!--Original code: https://gitlab.com/OpenRGBDevelopers/OpenRGBEffectsPlugin/-/tree/master?ref_type=heads-->
<html>
<head>
    <title>ORGB: Bloom</title>
    <meta description="Flower blooming effect.">
    <meta publisher="Jose Miranda (Port and improvements)">

    <meta property="speed" label="Speed" type="number" min="10" max="200" default="100">
    <meta property="saturation" label="Saturation" type="number" min="0" max="255" default="255">
</head>

<body style="margin: 0; padding: 0;">
    <canvas id="bloom-canvas" width="320" height="200"></canvas>
</body>

<script>
// -------------------------------------------------------------------
// SETUP
// -------------------------------------------------------------------

const canvas = document.getElementById('bloom-canvas');
const ctx = canvas.getContext('2d');
const canvasWidth = canvas.width;
const canvasHeight = canvas.height;

let flowers = []; // This will store the state for each "flower" (pixel)

// -------------------------------------------------------------------
// HELPER FUNCTIONS
// -------------------------------------------------------------------

/**
 * Resets and initializes the state for every pixel.
 * Each pixel gets a random starting hue and a random speed multiplier.
 */
function resetFlowers() {
    flowers = []; // Clear the existing array
    for (let i = 0; i < canvasWidth * canvasHeight; i++) {
        flowers.push({
            hue: Math.random() * 360, // Random starting hue (0-360)
            speed_mult: Math.random() + 1, // Random speed multiplier (1.0-2.0)
        });
    }
}

// -------------------------------------------------------------------
// MAIN ANIMATION LOOP
// -------------------------------------------------------------------

let lastTime = 0;
function update(currentTime) {
    const deltaTime = (currentTime - lastTime) / 1000;
    lastTime = currentTime;

    if (isNaN(deltaTime)) {
        requestAnimationFrame(update);
        return;
    }

    // This ensures that if the device layout changes, the effect resets properly.
    if (flowers.length !== canvasWidth * canvasHeight) {
        resetFlowers();
    }
    
    // Create a temporary buffer to draw the new frame
    const imageData = ctx.createImageData(canvasWidth, canvasHeight);
    const data = imageData.data;
    
    // Calculate the hue change for this frame
    const hue_change = (speed / 10) * deltaTime;

    // Update and draw each flower
    for (let i = 0; i < flowers.length; i++) {
        const flower = flowers[i];

        // Update the hue based on its unique speed and the master speed control
        flower.hue = (flower.hue + hue_change * flower.speed_mult) % 360;

        // Set the color in the image buffer using HSL color space
        // HSL's Saturation (0-100%) maps nicely from the slider's 0-255 range.
        const color = `hsl(${flower.hue}, ${saturation / 2.55}%, 50%)`;
        
        // This is a simple way to convert CSS color to RGB for the canvas buffer
        ctx.fillStyle = color; // Use the context to parse the color
        const rgb = ctx.fillStyle.match(/\d+/g); // Extract [r, g, b]

        const index = i * 4;
        data[index] = rgb[0];
        data[index + 1] = rgb[1];
        data[index + 2] = rgb[2];
        data[index + 3] = 255; // Alpha
    }

    // Draw the completed frame to the canvas at once
    ctx.putImageData(imageData, 0, 0);

    requestAnimationFrame(update);
}

// Initial setup and first call to start the animation
resetFlowers();
requestAnimationFrame(update);

</script>
</html>