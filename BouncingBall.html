<!DOCTYPE html><!--Original code: https://gitlab.com/OpenRGBDevelopers/OpenRGBEffectsPlugin/-/tree/master?ref_type=heads-->
<html>
<head>
    <title>ORGB: Bouncing Ball</title>
    <meta description="A ball bounces around your RGB setup.">
    <meta publisher="Jose Miranda (Port and improvements)">

    <meta property="ball_radius" label="Ball Radius" type="number" min="1" max="100" default="15">
    <meta property="gravity" label="Gravity" type="number" min="1" max="100" default="10">
    <meta property="horizontal_velocity" label="Horizontal Velocity" type="number" min="0" max="100" default="10">
    <meta property="spectrum_velocity" label="Spectrum Velocity" type="number" min="0" max="100" default="10">
    <meta property="drop_height_percent" label="Drop Height %" type="number" min="0" max="100" default="90">
</head>

<body style="margin: 0; padding: 0;">
    <canvas id="bouncingball-canvas" width="320" height="200"></canvas>
</body>

<script>
// -------------------------------------------------------------------
// SETUP
// -------------------------------------------------------------------

const canvas = document.getElementById('bouncingball-canvas');
const ctx = canvas.getContext('2d');
const canvasWidth = canvas.width;
const canvasHeight = canvas.height;

// --- Simulation State ---
let ball = {
    x: 0, y: 0,     // Position
    dx: 0, dy: 0,   // Velocity
    ddx: 0, ddy: 0, // Acceleration
    hue: 0,         // Color hue
    impactVelocity: 0 // Pre-calculated bounce velocity
};

// -------------------------------------------------------------------
// HELPER & PHYSICS FUNCTIONS
// -------------------------------------------------------------------

/** Converts gravity slider value (1-100) to an acceleration value */
function getGravity(value) {
    // This curve mimics the non-linear scaling in the original C++ code
    return value <= 10 ? value : (10 + Math.pow(1.07, value));
}

/** Calculates the initial velocity a ball has when dropped from a height */
function getImpactVelocity(gravity, dropHeight) {
    return Math.sqrt(2 * gravity * dropHeight);
}

/** Resets the ball's position and velocity */
function initSimulation() {
    const w = canvasWidth - 1;
    const h = canvasHeight - 1;

    // Set acceleration from gravity slider
    ball.ddy = getGravity(gravity) * 20; // Scale gravity for better visuals
    ball.ddx = 0;

    // Set horizontal velocity from slider
    ball.dx = horizontal_velocity * (ball.dx < 0 ? -1 : 1);
    
    // Calculate drop height and the resulting impact velocity
    const dropHeight = (drop_height_percent / 100.0) * h;
    ball.impactVelocity = getImpactVelocity(ball.ddy, dropHeight);

    // Set initial position and velocity
    ball.y = h - dropHeight;
    ball.dy = 0;
    ball.x = Math.random() * w; // Random start X position
    
    // Randomize initial horizontal direction
    if (Math.random() > 0.5) {
        ball.dx *= -1;
    }
}

// -------------------------------------------------------------------
// MAIN ANIMATION LOOP
// -------------------------------------------------------------------

let lastTime = 0;
let lastSettings = {}; // Used to detect when a setting changes
function update(currentTime) {
    const deltaTime = (currentTime - lastTime) / 1000;
    lastTime = currentTime;

    if (isNaN(deltaTime)) {
        requestAnimationFrame(update);
        return;
    }

    // Check if any settings have changed to re-initialize the simulation
    const currentSettings = { gravity, drop_height_percent };
    if (JSON.stringify(currentSettings) !== JSON.stringify(lastSettings)) {
        initSimulation();
        lastSettings = currentSettings;
    }

    // --- Update Physics ---
    const w = canvasWidth - 1;
    const h = canvasHeight - 1;
    const dt = deltaTime * 20; // Time multiplier for faster physics

    // Horizontal movement
    ball.dx += ball.ddx * dt;
    ball.x += ball.dx * dt;
    
    // Wall bounces
    if (ball.x < 0) {
        ball.x = 0;
        ball.dx *= -1;
    } else if (ball.x >= w) {
        ball.x = w;
        ball.dx *= -1;
    }
    
    // Vertical movement
    ball.dy += ball.ddy * dt;
    ball.y += ball.dy * dt;
    
    // Floor bounce
    if (ball.y >= h) {
        ball.y = h;
        // Reset velocity to the pre-calculated impact velocity to prevent energy loss/gain
        ball.dy = -ball.impactVelocity;
    }

    // Update color hue
    ball.hue = (ball.hue + (spectrum_velocity * deltaTime * 20)) % 360;

    // --- Render ---
    ctx.fillStyle = 'black';
    ctx.fillRect(0, 0, canvasWidth, canvasHeight);

    const imageData = ctx.createImageData(canvasWidth, canvasHeight);
    const data = imageData.data;
    const radiusSq = ball_radius * ball_radius;

    // Iterate through a bounding box around the ball for efficiency
    const startX = Math.max(0, Math.floor(ball.x - ball_radius));
    const endX = Math.min(canvasWidth, Math.ceil(ball.x + ball_radius));
    const startY = Math.max(0, Math.floor(ball.y - ball_radius));
    const endY = Math.min(canvasHeight, Math.ceil(ball.y + ball_radius));
    
    for (let py = startY; py < endY; py++) {
        for (let px = startX; px < endX; px++) {
            const distSq = Math.pow(px - ball.x, 2) + Math.pow(py - ball.y, 2);
            
            // If the pixel is inside the ball's radius
            if (distSq <= radiusSq) {
                const distance = Math.sqrt(distSq);
                const brightness = (1 - distance / ball_radius); // Brighter at the center
                
                const color = `hsl(${ball.hue}, 100%, ${brightness * 50}%)`;
                const rgb = color.match(/\d+/g); // Quick way to parse HSL to RGB
                
                const index = (py * canvasWidth + px) * 4;
                data[index] = rgb[0];
                data[index + 1] = rgb[1];
                data[index + 2] = rgb[2];
                data[index + 3] = 255;
            }
        }
    }

    ctx.putImageData(imageData, 0, 0);

    requestAnimationFrame(update);
}

// Initial call
initSimulation();
requestAnimationFrame(update);

</script>
</html>