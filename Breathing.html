<!DOCTYPE html><!--Original code: https://gitlab.com/OpenRGBDevelopers/OpenRGBEffectsPlugin/-/tree/master?ref_type=heads-->
<html>
<head>
    <title>ORGB: Breathing</title>
    <meta description="Fading in and out user selected colors across an entire zone.">
    <meta publisher="Jose Miranda (Port and improvements)">

    <meta property="speed" label="Speed" type="number" min="10" max="200" default="100">
    <meta property="random_colors" label="Random Colors" type="boolean" default="false">
    
    <meta property="color1" label="Color 1" type="color" default="#ff0000">
    <meta property="color2" label="Color 2" type="color" default="#00ff00">
    <meta property="color3" label="Color 3" type="color" default="#0000ff">
    <meta property="color4" label="Color 4" type="color" default="#ffff00">
</head>

<body style="margin: 0; padding: 0;">
    <canvas id="breathing-canvas" width="320" height="200"></canvas>
</body>

<script>
// -------------------------------------------------------------------
// SETUP
// -------------------------------------------------------------------

const canvas = document.getElementById('breathing-canvas');
const ctx = canvas.getContext('2d');

// Effect state variables
let progress = Math.PI; // Start at PI to trigger a color change on the first frame
let currentColor = { h: 0, s: 1, l: 0.5 }; // HSL color object
let colorLoopIndex = 0;

// -------------------------------------------------------------------
// MAIN ANIMATION LOOP
// -------------------------------------------------------------------

let lastTime = 0;
function update(currentTime) {
    const deltaTime = (currentTime - lastTime) / 1000;
    lastTime = currentTime;

    if (isNaN(deltaTime)) {
        requestAnimationFrame(update);
        return;
    }

    // Increment progress based on speed and time
    progress += (speed / 100.0) * deltaTime * 2; // Multiplier to sync speed with original effect

    // A full breathing cycle is from 0 to PI
    if (progress >= Math.PI) {
        progress %= Math.PI;
        
        if (random_colors) {
            // Generate a random HSL color
            currentColor.h = Math.random() * 360;
            currentColor.s = 1; // Full saturation
        } else {
            // Get the next color from the user-defined list
            const colorList = [color1, color2, color3, color4].filter(c => c); // Filter out empty colors
            
            const nextColorHex = colorList[colorLoopIndex];
            
            // Convert the hex color to HSL
            const r = parseInt(nextColorHex.slice(1, 3), 16) / 255;
            const g = parseInt(nextColorHex.slice(3, 5), 16) / 255;
            const b = parseInt(nextColorHex.slice(5, 7), 16) / 255;

            const max = Math.max(r, g, b), min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;

            if (max === min) {
                h = s = 0; // achromatic
            } else {
                const d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                switch (max) {
                    case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                    case g: h = (b - r) / d + 2; break;
                    case b: h = (r - g) / d + 4; break;
                }
                h /= 6;
            }
            
            currentColor.h = h * 360;
            currentColor.s = s;

            // Move to the next color in the list for the next cycle
            colorLoopIndex = (colorLoopIndex + 1) % colorList.length;
        }
    }

    // Calculate the brightness (lightness) using a sine wave for the breathing effect
    // pow(sin(progress), 3) creates a nice curve with a longer hold at the dark phase.
    const lightness = Math.pow(Math.sin(progress), 3);
    
    // Set the fill style using the current HSL color
    ctx.fillStyle = `hsl(${currentColor.h}, ${currentColor.s * 100}%, ${lightness * 50}%)`;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    requestAnimationFrame(update);
}

// Initial call to start the animation
requestAnimationFrame(update);

</script>
</html>