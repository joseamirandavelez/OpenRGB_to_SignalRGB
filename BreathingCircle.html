<!DOCTYPE html>
<html>
<head>
    <title>Breathing Circle</title>
    <meta description="A breathing circle effect.">
    <meta publisher="Jose Miranda (Conversion and improvements)">

    <meta property="speed" label="Speed" type="number" min="10" max="100" default="50">
    <meta property="thickness" label="Thickness" type="number" min="1" max="20" default="10">
    <meta property="random_colors" label="Random Colors" type="boolean" default="true">
    <meta property="user_color" label="Color" type="color" default="#00ff00">
</head>

<body style="margin: 0; padding: 0;">
    <canvas id="breathingcircle-canvas" width="320" height="200"></canvas>
</body>

<script>
// -------------------------------------------------------------------
// SETUP
// -------------------------------------------------------------------

const canvas = document.getElementById('breathingcircle-canvas');
const ctx = canvas.getContext('2d');
const canvasWidth = canvas.width;
const canvasHeight = canvas.height;

// Effect state variables
let time = 0.0;
let progress = 0.0;
let was_growing = true;
let activeColor = [0, 255, 0]; // Default to green

// -------------------------------------------------------------------
// HELPER FUNCTIONS
// -------------------------------------------------------------------

function hexToRgb(hex) {
    if (!hex) return [0, 255, 0];
    const r = parseInt(hex.slice(1, 3), 16);
    const g = parseInt(hex.slice(3, 5), 16);
    const b = parseInt(hex.slice(5, 7), 16);
    return [r, g, b];
}

function randomRgb() {
    return [Math.random() * 255, Math.random() * 255, Math.random() * 255];
}

// -------------------------------------------------------------------
// MAIN LOGIC
// -------------------------------------------------------------------

function getColor(x, y, w, h) {
    // Calculate the pixel's normalized distance from the center (0.0 to ~0.7)
    const distance = Math.sqrt(Math.pow(0.5 - x / w, 2) + Math.pow(0.5 - y / h, 2));

    // The progress variable (radius) breathes from 0.0 to 0.7
    // We calculate the thickness as a fraction of the total canvas size
    const thickness_norm = thickness / (w + h);

    // If the pixel's distance is outside the current ring, it's black
    if (distance > progress || distance < progress - thickness_norm) {
        return 'rgb(0,0,0)';
    }

    // Otherwise, return the active color
    return `rgb(${activeColor[0]}, ${activeColor[1]}, ${activeColor[2]})`;
}

// -------------------------------------------------------------------
// MAIN ANIMATION LOOP
// -------------------------------------------------------------------

let lastTime = 0;
function update(currentTime) {
    const deltaTime = (currentTime - lastTime) / 1000;
    lastTime = currentTime;

    if (isNaN(deltaTime)) {
        requestAnimationFrame(update);
        return;
    }

    // --- Update State ---
    const prevProgress = progress;

    // Update time based on speed, which drives the animation
    time += (speed / 100) * deltaTime * 5;
    
    // The sine function creates a smooth breathing motion for the radius
    // The circle's radius will oscillate between 0 and 0.7
    progress = 0.35 * (1 + Math.sin(time)); 
    
    const is_growing = progress > prevProgress;

    // Check if a cycle has just completed (changed from shrinking to growing)
    if (is_growing && !was_growing) {
        // Pick a new color for the next breath
        if (random_colors) {
            activeColor = randomRgb();
        } else {
            activeColor = hexToRgb(user_color);
        }
    }
    was_growing = is_growing;

    // --- Render ---
    ctx.fillStyle = 'black';
    ctx.fillRect(0, 0, canvasWidth, canvasHeight);

    // This is faster than per-pixel rendering for this specific effect
    const centerX = canvasWidth / 2;
    const centerY = canvasHeight / 2;
    const radius_pixels = progress * (canvasWidth / 2);
    const thickness_pixels = (thickness / (canvasWidth + canvasHeight)) * (canvasWidth + canvasHeight) * 2;
    
    ctx.strokeStyle = `rgb(${activeColor[0]}, ${activeColor[1]}, ${activeColor[2]})`;
    ctx.lineWidth = thickness_pixels;
    
    ctx.beginPath();
    ctx.arc(centerX, centerY, radius_pixels, 0, 2 * Math.PI);
    ctx.stroke();

    requestAnimationFrame(update);
}

// Initial color selection and first animation call
activeColor = random_colors ? randomRgb() : hexToRgb(user_color);
requestAnimationFrame(update);

</script>
</html>