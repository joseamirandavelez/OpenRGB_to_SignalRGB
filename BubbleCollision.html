<!DOCTYPE html><!--Original code: https://gitlab.com/OpenRGBDevelopers/OpenRGBEffectsPlugin/-/tree/master?ref_type=heads-->
<html>
<head>
    <title>ORGB: Bubble Collision</title>
    <meta description="Bubbles spawn with speed and direction, bouncing off walls and each other.">
    <meta publisher="Jose Miranda (Port and improvements)">

    <meta property="speed" label="Speed" type="number" min="1" max="100" default="100">
    <meta property="max_bubbles" label="Max Bubbles" type="number" min="1" max="50" default="10">
    <meta property="bubble_size" label="Bubble Size" type="number" min="1" max="50" default="20">
    <meta property="spawn_rate" label="Spawn Rate" type="number" min="1" max="1000" default="350">
    <meta property="palette" label="Color Palette" type="list" values="Vaporwave,Ocean,Sunset,Forest,Fire,Rainbow Puke" default="Rainbow Puke">
    <meta property="random_colors" label="Random Colors" type="boolean" default="false">
    <meta property="background_color" label="Background" type="color" default="#000000" min="0" max="360">
</head>

<body style="margin: 0; padding: 0;">
    <canvas id="bubble-collision-canvas" width="320" height="200"></canvas>
</body>

<script>
// -------------------------------------------------------------------
// SETUP
// -------------------------------------------------------------------

const canvas = document.getElementById('bubble-collision-canvas');
const ctx = canvas.getContext('2d');
const canvasWidth = canvas.width;
const canvasHeight = canvas.height;

// Array to hold active bubble objects
let bubbles = [];

// A timer to control bubble spawning
let spawnTimer = 0;

// Store the previous state of the meta properties to detect changes
let lastSpeed = speed;
let lastMaxBubbles = max_bubbles;
let lastBubbleSize = bubble_size;
let lastSpawnRate = spawn_rate;
let lastPalette = palette;
let lastRandomColors = random_colors;
let lastBackgroundColor = background_color;


// -------------------------------------------------------------------
// COLOR UTILITIES
// -------------------------------------------------------------------

/** Converts a hex color string to an RGB array. */
function hexToRgb(hex) {
    if (!hex) return [0, 0, 0];
    const r = parseInt(hex.slice(1, 3), 16);
    const g = parseInt(hex.slice(3, 5), 16);
    const b = parseInt(hex.slice(5, 7), 16);
    return [r, g, b];
}

/** Returns a random RGB color array. */
function randomRgb() {
    return [Math.random() * 255, Math.random() * 255, Math.random() * 255];
}

// -------------------------------------------------------------------
// BUBBLE LOGIC
// -------------------------------------------------------------------

// Define some color palettes for the visualizer
const colorPalettes = {
    "Vaporwave": ["#FF71CE", "#B967FF", "#01CDFE", "#05FFA1", "#FFFB96"],
    "Ocean": ["#00007F", "#0000FF", "#00FFFF", "#00AAFF"],
    "Sunset": ["#FF2100", "#AB006D", "#C01C52", "#D53737", "#EA531B", "#FF6E00"],
    "Forest": ["#113C16", "#2D7F39", "#56A661", "#80D08A", "#AAD8B1"],
    "Fire": ["#FF0000", "#FF6A00", "#FFD700", "#FFFF00", "#FF8C00"],
    "Rainbow Puke": ["#FF0000", "#FF7F00", "#FFFF00", "#00FF00", "#0000FF", "#4B0082", "#9400D3"]
};

/** Resets the animation and state variables. */
function resetAnimation() {
    bubbles = [];
    spawnTimer = 0;
    lastSpeed = speed;
    lastMaxBubbles = max_bubbles;
    lastBubbleSize = bubble_size;
    lastSpawnRate = spawn_rate;
    lastPalette = palette;
    lastRandomColors = random_colors;
    lastBackgroundColor = background_color;
}

/** Creates and initializes a new bubble object. */
function initBubble() {
    let color;

    if (random_colors) {
        color = randomRgb();
    } else {
        // Use the selected palette from the meta property
        const paletteColors = colorPalettes[palette];
        
        // Randomly select a color from the chosen palette
        const randomColorHex = paletteColors[Math.floor(Math.random() * paletteColors.length)];
        color = hexToRgb(randomColorHex);
    }
    
    // Assign a random size
    const randomRadius = bubble_size * (0.5 + Math.random());
    
    // Assign a random initial velocity, inversely proportional to size
    const angle = Math.random() * Math.PI * 2;
    const initialSpeed = speed / (randomRadius / bubble_size);

    bubbles.push({
        id: Math.random(),
        x: Math.random() * canvasWidth,
        y: Math.random() * canvasHeight,
        radius: randomRadius,
        color: color,
        velocity: {
            x: Math.cos(angle) * initialSpeed,
            y: Math.sin(angle) * initialSpeed
        }
    });
}

/** Updates the position and checks for collisions for each bubble. */
function updateBubbles(deltaTime) {
    for (let i = 0; i < bubbles.length; i++) {
        const bubble = bubbles[i];
        
        // Update position based on velocity
        bubble.x += bubble.velocity.x * deltaTime;
        bubble.y += bubble.velocity.y * deltaTime;

        // Wall collision detection and response
        if (bubble.x - bubble.radius < 0) {
            bubble.velocity.x *= -1;
            bubble.x = bubble.radius;
        } else if (bubble.x + bubble.radius > canvasWidth) {
            bubble.velocity.x *= -1;
            bubble.x = canvasWidth - bubble.radius;
        }
        if (bubble.y - bubble.radius < 0) {
            bubble.velocity.y *= -1;
            bubble.y = bubble.radius;
        } else if (bubble.y + bubble.radius > canvasHeight) {
            bubble.velocity.y *= -1;
            bubble.y = canvasHeight - bubble.radius;
        }
    }
}

/** Checks for and resolves collisions between bubbles. */
function checkCollisions() {
    for (let i = 0; i < bubbles.length; i++) {
        for (let j = i + 1; j < bubbles.length; j++) {
            const b1 = bubbles[i];
            const b2 = bubbles[j];

            const dx = b1.x - b2.x;
            const dy = b1.y - b2.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            // Check for collision
            if (distance < b1.radius + b2.radius) {
                // To prevent sticking, move bubbles apart slightly
                const overlap = (b1.radius + b2.radius) - distance;
                b1.x += (dx / distance) * overlap / 2;
                b1.y += (dy / distance) * overlap / 2;
                b2.x -= (dx / distance) * overlap / 2;
                b2.y -= (dy / distance) * overlap / 2;

                // Simple 2D elastic collision response
                const normalX = dx / distance;
                const normalY = dy / distance;
                const tangentX = -normalY;
                const tangentY = normalX;

                const v1n = b1.velocity.x * normalX + b1.velocity.y * normalY;
                const v1t = b1.velocity.x * tangentX + b1.velocity.y * tangentY;
                const v2n = b2.velocity.x * normalX + b2.velocity.y * normalY;
                const v2t = b2.velocity.x * tangentX + b2.velocity.y * tangentY;

                // Swap normal velocities
                b1.velocity.x = v2n * normalX + v1t * tangentX;
                b1.velocity.y = v2n * normalY + v1t * tangentY;
                b2.velocity.x = v1n * normalX + v2t * tangentX;
                b2.velocity.y = v1n * normalY + v2t * tangentY;
            }
        }
    }
}

/** Renders all bubbles to the canvas. */
function renderBubbles() {
    const backgroundRgb = hexToRgb(background_color);

    // Clear the canvas with the background color
    ctx.fillStyle = `rgb(${backgroundRgb[0]}, ${backgroundRgb[1]}, ${backgroundRgb[2]})`;
    ctx.fillRect(0, 0, canvasWidth, canvasHeight);

    // Draw each bubble
    for (const bubble of bubbles) {
        ctx.beginPath();
        ctx.arc(bubble.x, bubble.y, bubble.radius, 0, Math.PI * 2);
        const [r, g, b] = bubble.color;
        ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
        ctx.fill();
    }
}

// -------------------------------------------------------------------
// MAIN ANIMATION LOOP
// -------------------------------------------------------------------

let lastTime = 0;
function update(currentTime) {
    const deltaTime = (currentTime - lastTime) / 1000;
    lastTime = currentTime;

    if (isNaN(deltaTime)) {
        requestAnimationFrame(update);
        return;
    }

    // Check if any controls have changed and reset if needed
    if (speed !== lastSpeed || max_bubbles !== lastMaxBubbles || bubble_size !== lastBubbleSize ||
        spawn_rate !== lastSpawnRate || palette !== lastPalette || random_colors !== lastRandomColors ||
        background_color !== lastBackgroundColor) {
        resetAnimation();
    }

    // Spawn new bubbles at a controlled rate
    spawnTimer += deltaTime;
    if (bubbles.length < max_bubbles && spawnTimer > 1 / (spawn_rate / 100)) {
        initBubble();
        spawnTimer = 0;
    }

    // Update positions and check for collisions
    updateBubbles(deltaTime);
    checkCollisions();
    
    // Render the new frame
    renderBubbles();
    
    requestAnimationFrame(update);
}

// Initial call
requestAnimationFrame(update);
</script>
</html>
