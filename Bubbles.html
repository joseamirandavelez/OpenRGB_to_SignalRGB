<!DOCTYPE html>
<html>
<head>
    <title>Bubbles</title>
    <meta description="Bloop bloop.">
    <meta publisher="Jose Miranda (Conversion and improvements)">

    <meta property="speed" label="Speed" type="number" min="1" max="100" default="50">
    <meta property="max_bubbles" label="Max Bubbles" type="number" min="1" max="20" default="10">
    <meta property="rarity" label="Rarity (lower is more)" type="number" min="1" max="1000" default="50">
    <meta property="max_expansion" label="Max Expansion" type="number" min="1" max="500" default="100">
    <meta property="bubbles_thickness" label="Bubbles Thickness" type="number" min="1" max="50" default="10">
    <meta property="random_colors" label="Random Colors" type="boolean" default="true">
    <meta property="background_color" label="Background" type="color" default="#000000">
    <meta property="color1" label="Bubble Color 1" type="color" default="#ff0000">
    <meta property="color2" label="Bubble Color 2" type="color" default="#00ff00">
    <meta property="color3" label="Bubble Color 3" type="color" default="#0000ff">
    <meta property="color4" label="Bubble Color 4" type="color" default="#ffff00">
    <meta property="color5" label="Bubble Color 5" type="color" default="#ff00ff">
</head>

<body style="margin: 0; padding: 0;">
    <canvas id="bubbles-canvas" width="320" height="200"></canvas>
</body>

<script>
// -------------------------------------------------------------------
// SETUP
// -------------------------------------------------------------------

const canvas = document.getElementById('bubbles-canvas');
const ctx = canvas.getContext('2d');
const canvasWidth = canvas.width;
const canvasHeight = canvas.height;

let bubbles = []; // Array to hold active bubble objects

// -------------------------------------------------------------------
// COLOR UTILITIES
// -------------------------------------------------------------------

function hexToRgb(hex) {
    if (!hex) return [0, 0, 0];
    const r = parseInt(hex.slice(1, 3), 16);
    const g = parseInt(hex.slice(3, 5), 16);
    const b = parseInt(hex.slice(5, 7), 16);
    return [r, g, b];
}

function randomRgb() {
    return [Math.random() * 255, Math.random() * 255, Math.random() * 255];
}

function screenBlend(base, blend) {
    const r = 1 - (1 - base[0] / 255) * (1 - blend[0] / 255);
    const g = 1 - (1 - base[1] / 255) * (1 - blend[1] / 255);
    const b = 1 - (1 - base[2] / 255) * (1 - blend[2] / 255);
    return [r * 255, g * 255, b * 255];
}

// -------------------------------------------------------------------
// BUBBLE LOGIC
// -------------------------------------------------------------------

function initBubble() {
    const userColors = [color1, color2, color3, color4, color5].filter(c => c && c !== "#000000");
    let color;

    if (random_colors) {
        color = randomRgb();
    } else if (userColors.length > 0) {
        color = hexToRgb(userColors[Math.floor(Math.random() * userColors.length)]);
    } else {
        color = [255, 255, 255]; // Failsafe to white
    }

    bubbles.push({
        radius: 0,
        speed: 1 + Math.random() * 10,
        color: color,
        center: { x: Math.random(), y: Math.random() }
    });
}

function expandBubbles(deltaTime) {
    for (const bubble of bubbles) {
        bubble.radius += 0.2 * (speed / 10) * bubble.speed * deltaTime * 60;
    }
}

function cleanupBubbles() {
    bubbles = bubbles.filter(bubble => bubble.radius < max_expansion);
}

function getColor(x, y, w, h) {
    let topBubble = {
        color_idx: -1,
        val: 0
    };

    // Find the most prominent bubble at this pixel location
    for (let i = 0; i < bubbles.length; i++) {
        const bubble = bubbles[i];
        const distance = Math.sqrt(Math.pow(w * bubble.center.x - x, 2) + Math.pow(h * bubble.center.y - y, 2));
        const shallow = Math.abs(distance - bubble.radius) / (0.1 * bubbles_thickness);
        
        // Using pow(shallow, 2) creates a soft ring
        const value = Math.min(255, 255 * (1 / Math.pow(shallow, 2)));

        if (value > topBubble.val) {
            topBubble = { color_idx: i, val: value };
        }
    }

    const backgroundRgb = hexToRgb(background_color);

    if (topBubble.color_idx >= 0) {
        const bubble = bubbles[topBubble.color_idx];
        const brightness = topBubble.val / 255.0;
        
        // Apply brightness to the bubble's base color
        const bubbleColor = [
            bubble.color[0] * brightness,
            bubble.color[1] * brightness,
            bubble.color[2] * brightness
        ];
        
        // Blend the final bubble color on top of the background
        const finalPixel = screenBlend(backgroundRgb, bubbleColor);
        return `rgb(${finalPixel[0]}, ${finalPixel[1]}, ${finalPixel[2]})`;
    }

    // No bubble here, just return the background color
    return `rgb(${backgroundRgb[0]}, ${backgroundRgb[1]}, ${backgroundRgb[2]})`;
}

// -------------------------------------------------------------------
// MAIN ANIMATION LOOP
// -------------------------------------------------------------------

let lastTime = 0;
function update(currentTime) {
    const deltaTime = (currentTime - lastTime) / 1000;
    lastTime = currentTime;

    if (isNaN(deltaTime)) {
        requestAnimationFrame(update);
        return;
    }

    // --- Update State ---
    expandBubbles(deltaTime);

    // Randomly spawn new bubbles
    if (Math.random() < (1 / rarity) && bubbles.length < max_bubbles) {
        initBubble();
    }

    cleanupBubbles();
    
    // --- Render ---
    for (let y = 0; y < canvasHeight; y++) {
        for (let x = 0; x < canvasWidth; x++) {
            ctx.fillStyle = getColor(x, y, canvasWidth, canvasHeight);
            ctx.fillRect(x, y, 1, 1);
        }
    }
    
    requestAnimationFrame(update);
}

// Initial call
requestAnimationFrame(update);

</script>
</html>