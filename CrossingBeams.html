<!DOCTYPE html>
<html>
<head>
    <title>Crossing Beams</title>
    <meta description="Two beams that move horizontally and vertically.">
    <meta publisher="Jose Miranda (Conversion and improvements)">

    <meta property="speed" label="Master Speed" type="number" min="1" max="10" default="5">
    <meta property="h_speed" label="Horizontal Speed" type="number" min="1" max="100" default="50">
    <meta property="v_speed" label="Vertical Speed" type="number" min="1" max="100" default="50">
    <meta property="glow" label="Glow" type="number" min="1" max="100" default="50">
    <meta property="thickness" label="Thickness" type="number" min="0" max="100" default="5">
    <meta property="random_colors" label="Random Colors" type="boolean" default="false">
    <meta property="color1" label="Horizontal Beam" type="color" default="#ff0000">
    <meta property="color2" label="Vertical Beam" type="color" default="#0000ff">
</head>

<body style="margin: 0; padding: 0;">
    <canvas id="crossingbeams-canvas" width="320" height="200"></canvas>
</body>

<script>
// -------------------------------------------------------------------
// SETUP
// -------------------------------------------------------------------

const canvas = document.getElementById('crossingbeams-canvas');
const ctx = canvas.getContext('2d');
const canvasWidth = canvas.width;
const canvasHeight = canvas.height;

// Effect state variables
let progress = 0.0;
let hsv1 = { h: 0, s: 1, v: 1 }; // H Beam
let hsv2 = { h: 240, s: 1, v: 1 }; // V Beam

// -------------------------------------------------------------------
// COLOR UTILITIES
// -------------------------------------------------------------------

function hexToHsv(hex) {
    if (!hex) return { h: 0, s: 0, v: 1 };
    let r = parseInt(hex.slice(1, 3), 16) / 255;
    let g = parseInt(hex.slice(3, 5), 16) / 255;
    let b = parseInt(hex.slice(5, 7), 16) / 255;

    let max = Math.max(r, g, b), min = Math.min(r, g, b);
    let h, s, v = max;
    let d = max - min;
    s = max === 0 ? 0 : d / max;

    if (max === min) { h = 0; } 
    else {
        switch (max) {
            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
            case g: h = (b - r) / d + 2; break;
            case b: h = (r - g) / d + 4; break;
        }
        h /= 6;
    }
    return { h: h * 360, s: s, v: v };
}

function hsvToRgb(h, s, v) {
    let r, g, b;
    const i = Math.floor(h * 6);
    const f = h * 6 - i;
    const p = v * (1 - s);
    const q = v * (1 - f * s);
    const t = v * (1 - (1 - f) * s);
    switch (i % 6) {
        case 0: r = v, g = t, b = p; break; case 1: r = q, g = v, b = p; break;
        case 2: r = p, g = v, b = t; break; case 3: r = p, g = q, b = v; break;
        case 4: r = t, g = p, b = v; break; case 5: r = v, g = p, b = q; break;
    }
    return [r * 255, g * 255, b * 255];
}

function screenBlend(c1, c2) {
    return [
        (1 - (1 - c1[0] / 255) * (1 - c2[0] / 255)) * 255,
        (1 - (1 - c1[1] / 255) * (1 - c2[1] / 255)) * 255,
        (1 - (1 - c1[2] / 255) * (1 - c2[2] / 255)) * 255
    ];
}

// -------------------------------------------------------------------
// MAIN LOGIC
// -------------------------------------------------------------------

function getColor(x, y, w, h) {
    // Calculate the current position of the horizontal and vertical beams (0 to 1 range)
    const x_progress = 0.5 * (1 + Math.sin(0.01 * h_speed * progress));
    const y_progress = 0.5 * (1 + Math.sin(0.01 * v_speed * progress));

    // Convert to canvas coordinates
    const beam_x = x_progress * w;
    const beam_y = y_progress * h;

    // Calculate pixel's distance from each beam
    const distance_x = Math.abs(beam_x - x);
    const distance_y = Math.abs(beam_y - y);
    
    // Calculate brightness of each beam at this pixel based on distance, thickness, and glow
    const x_brightness = 1 - Math.min(1, Math.pow(distance_x / w, distance_x > thickness ? 0.01 * glow : 1));
    const y_brightness = 1 - Math.min(1, Math.pow(distance_y / h, distance_y > thickness ? 0.01 * glow : 1));

    // Get the final RGB color for each beam
    const color1_rgb = hsvToRgb(hsv1.h, hsv1.s, hsv1.v * x_brightness);
    const color2_rgb = hsvToRgb(hsv2.h, hsv2.s, hsv2.v * y_brightness);

    // Blend the two colors together. Screen mode makes intersections brighter.
    const final_color = screenBlend(color1_rgb, color2_rgb);
    
    return `rgb(${final_color[0]}, ${final_color[1]}, ${final_color[2]})`;
}

// -------------------------------------------------------------------
// MAIN ANIMATION LOOP
// -------------------------------------------------------------------

let lastTime = 0;
let lastColor1 = "", lastColor2 = "";
function update(currentTime) {
    const deltaTime = (currentTime - lastTime) / 1000;
    lastTime = currentTime;

    if (isNaN(deltaTime)) {
        requestAnimationFrame(update);
        return;
    }

    progress += speed * deltaTime;

    if (random_colors) {
        hsv1.h = (hsv1.h + 0.1 * speed * deltaTime) % 360;
        hsv2.h = (hsv2.h + 0.1 * speed * deltaTime) % 360;
    } else {
        // Update user colors only when they change
        if(color1 !== lastColor1) { hsv1 = hexToHsv(color1); lastColor1 = color1; }
        if(color2 !== lastColor2) { hsv2 = hexToHsv(color2); lastColor2 = color2; }
    }
    
    // Render
    for (let y = 0; y < canvasHeight; y++) {
        for (let x = 0; x < canvasWidth; x++) {
            ctx.fillStyle = getColor(x, y, canvasWidth, canvasHeight);
            ctx.fillRect(x, y, 1, 1);
        }
    }
    
    requestAnimationFrame(update);
}

// Initial call
requestAnimationFrame(update);

</script>
</html>