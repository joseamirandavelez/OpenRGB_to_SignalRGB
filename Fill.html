<!DOCTYPE html><!--Original code: https://gitlab.com/OpenRGBDevelopers/OpenRGBEffectsPlugin/-/tree/master?ref_type=heads-->
<html>
<head>
    <title>ORGB: Fill</title>
    <meta description="Progressively fills your devices with a defined color.">
    <meta publisher="Jose Miranda (Port and improvements)">

    <meta property="speed" label="Speed" type="number" min="10" max="20" default="5">
    <meta property="random_colors" label="Random Colors" type="boolean" default="true">
    <meta property="user_color" label="Color" type="color" min="0" max="360" default="#ffffff">
</head>

<body style="margin: 0; padding: 0;">
    <canvas id="fill-canvas" width="320" height="200"></canvas>
</body>

<script>
// -------------------------------------------------------------------
// SETUP
// -------------------------------------------------------------------

const canvas = document.getElementById('fill-canvas');
const ctx = canvas.getContext('2d');
const canvasWidth = canvas.width;
const canvasHeight = canvas.height;
const imageData = ctx.createImageData(canvasWidth, canvasHeight);
const pixels = imageData.data;

// Effect state variables
let time = 0.0;
let activeColor = [255, 255, 255]; // The color used for the current fill cycle
let lastRandomColors = random_colors;
let lastUserColor = user_color;

// -------------------------------------------------------------------
// HELPER FUNCTIONS
// -------------------------------------------------------------------

function hexToRgb(hex) {
    if (!hex) return [255, 255, 255];
    const r = parseInt(hex.slice(1, 3), 16);
    const g = parseInt(hex.slice(3, 5), 16);
    const b = parseInt(hex.slice(5, 7), 16);
    return [r, g, b];
}

function randomRgb() {
    return [Math.random() * 255, Math.random() * 255, Math.random() * 255];
}

function applyBrightness(rgb, brightness) {
    return [rgb[0] * brightness, rgb[1] * brightness, rgb[2] * brightness];
}

// -------------------------------------------------------------------
// MAIN ANIMATION LOOP
// -------------------------------------------------------------------

let lastTime = 0;
function update(currentTime) {
    const deltaTime = (currentTime - lastTime) / 1000;
    lastTime = currentTime;

    if (isNaN(deltaTime)) {
        requestAnimationFrame(update);
        return;
    }

    // --- Update State ---
    const old_time = time;
    time = (time + 0.01 * speed * deltaTime * 20) % 2;
    const progress = time % 1.0;

    // A cycle completes when progress wraps around from ~1.0 back to ~0.0
    if (time < old_time) {
        if (random_colors) {
            activeColor = randomRgb();
        } else {
            activeColor = hexToRgb(user_color);
        }
    }

    if (random_colors !== lastRandomColors || user_color !== lastUserColor) {
        if (random_colors) {
            activeColor = randomRgb();
        } else {
            activeColor = hexToRgb(user_color);
        }
        lastRandomColors = random_colors;
        lastUserColor = user_color;
    }

    const isFilling = Math.floor(time) % 2 === 0;

    // --- Render ---
    for (let x = 0; x < canvasWidth; x++) {
        const position = progress * canvasWidth;
        const distance = position - x;

        let finalColor;
        
        if (isFilling) {
            if (distance > 1) {
                finalColor = activeColor;
            } else if (distance > 0) {
                finalColor = applyBrightness(activeColor, distance);
            } else {
                finalColor = [0, 0, 0];
            }
        } else {
            const brightness = 1 - progress;
            finalColor = applyBrightness(activeColor, brightness);
        }

        for (let y = 0; y < canvasHeight; y++) {
            const index = (y * canvasWidth + x) * 4;
            pixels[index] = Math.round(finalColor[0]);
            pixels[index + 1] = Math.round(finalColor[1]);
            pixels[index + 2] = Math.round(finalColor[2]);
            pixels[index + 3] = 255;
        }
    }
    
    ctx.putImageData(imageData, 0, 0);

    requestAnimationFrame(update);
}

activeColor = random_colors ? randomRgb() : hexToRgb(user_color);
requestAnimationFrame(update);
</script>
</html>
