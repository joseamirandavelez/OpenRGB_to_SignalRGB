<!DOCTYPE html><!--Original code: https://gitlab.com/OpenRGBDevelopers/OpenRGBEffectsPlugin/-/tree/master?ref_type=heads-->
<html>
<head>
    <title>ORGB: Hypnotoad</title>
    <meta description="You wont escape this.">
    <meta publisher="Jose Miranda (Port and improvements)">

    <meta property="animation_speed" label="Animation Speed" type="number" min="10" max="100" default="50">
    <meta property="color_rotation_speed" label="Rotation Speed" type="number" min="10" max="100" default="20">
    <meta property="spacing" label="Spacing" type="number" min="1" max="10" default="5">
    <meta property="thickness" label="Thickness" type="number" min="1" max="10" default="5">
    <meta property="center_x" label="X Position (%)" type="number" min="0" max="100" default="50">
    <meta property="center_y" label="Y Position (%)" type="number" min="0" max="100" default="50">
    <meta property="animation_direction" label="Animation Direction" type="list" values="To the Inside,To the Outside" default="To the Inside">
    <meta property="color_rotation_direction" label="Rotation Direction" type="list" values="Clockwise,Counter-clockwise" default="Clockwise">
    
    <meta property="color_mode" label="Color Mode" type="list" values="Rainbow,Custom" default="Rainbow">
    <meta property="color1" label="Color 1" type="color" min="0" max="360" default="#ff0000">
    <meta property="color2" label="Color 2" type="color" min="0" max="360" default="#00ff00">
    <meta property="color3" label="Color 3" type="color" min="0" max="360" default="#0000ff">
    <meta property="color4" label="Color 4" type="color" min="0" max="360" default="#ff0000">
</head>

<body style="margin: 0; padding: 0;">
    <canvas id="hypnotoad-canvas" width="320" height="200"></canvas>
</body>

<script>
// -------------------------------------------------------------------
// SETUP
// -------------------------------------------------------------------

const canvas = document.getElementById('hypnotoad-canvas');
const ctx = canvas.getContext('2d');
const canvasWidth = canvas.width;
const canvasHeight = canvas.height;
const imageData = ctx.createImageData(canvasWidth, canvasHeight);
const pixels = imageData.data;

const gradientCanvas = document.createElement('canvas');
gradientCanvas.width = 256;
gradientCanvas.height = 1;
const gradientCtx = gradientCanvas.getContext('2d', { willReadFrequently: true });
let gradientData = null;

let progress = 0.0;
let lastColorSettings = "";
let lastColorMode = "";

// -------------------------------------------------------------------
// HELPER FUNCTIONS
// -------------------------------------------------------------------

/** Converts HSL values to an RGB array. */
function hslToRgb(h, s, l) {
    let r, g, b;
    h = h / 360;
    s = s / 100;
    l = l / 100;

    if (s === 0) {
        r = g = b = l; // achromatic
    } else {
        const hue2rgb = (p, q, t) => {
            if (t < 0) t += 1;
            if (t > 1) t -= 1;
            if (t < 1 / 6) return p + (q - p) * 6 * t;
            if (t < 1 / 2) return q;
            if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
            return p;
        };

        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        const p = 2 * l - q;
        r = hue2rgb(p, q, h + 1 / 3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1 / 3);
    }

    return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
}

function hexToRgb(hex) {
    if (!hex) return [0, 0, 0];
    const r = parseInt(hex.slice(1, 3), 16);
    const g = parseInt(hex.slice(3, 5), 16);
    const b = parseInt(hex.slice(5, 7), 16);
    return [r, g, b];
}

function generateGradient() {
    let colors = [color1, color2, color3, color4].filter(c => c && c !== "#000000");
    if (colors.length < 2) colors = ["#ff0000", "#0000ff"];

    const grad = gradientCtx.createLinearGradient(0, 0, gradientCanvas.width, 0);
    const step = 1.0 / (colors.length - 1);
    for (let i = 0; i < colors.length; i++) {
        grad.addColorStop(i * step, colors[i]);
    }
    gradientCtx.fillStyle = grad;
    gradientCtx.fillRect(0, 0, gradientCanvas.width, 1);
    gradientData = gradientCtx.getImageData(0, 0, gradientCanvas.width, 1).data;
}

// -------------------------------------------------------------------
// MAIN ANIMATION LOOP
// -------------------------------------------------------------------

let lastTime = 0;
function update(currentTime) {
    const deltaTime = (currentTime - lastTime) / 1000;
    lastTime = currentTime;

    if (isNaN(deltaTime)) {
        requestAnimationFrame(update);
        return;
    }

    // Update animation progress
    progress += 0.1 * (animation_speed / 10.0) * deltaTime * 60;

    // Regenerate custom gradient only when colors change
    if(color_mode === "Custom") {
        const currentSettings = color1 + color2 + color3 + color4;
        if(currentSettings !== lastColorSettings || color_mode !== lastColorMode) {
            generateGradient();
            lastColorSettings = currentSettings;
        }
    }
    lastColorMode = color_mode;

    // Render
    const centerX = canvasWidth * (center_x / 100.0);
    const centerY = canvasHeight * (center_y / 100.0);

    const anim_dir = (animation_direction === "To the Inside") ? 1 : -1;
    const color_rot_dir = (color_rotation_direction === "Clockwise") ? -1 : 1;

    const anim_mult = 0.01 * animation_speed * anim_dir;
    const color_mult = 0.01 * color_rotation_speed * color_rot_dir;

    const fade_mult = (11 - thickness);

    for (let y = 0; y < canvasHeight; y++) {
        for (let x = 0; x < canvasWidth; x++) {
            const pixelIndex = (y * canvasWidth + x) * 4;

            const angle = Math.atan2(y - centerY, x - centerX) * 180 / Math.PI;
            const distance = Math.sqrt(Math.pow(centerX - x, 2) + Math.pow(centerY - y, 2));

            const value_wave = Math.cos(anim_mult * distance / (0.1 * spacing) + progress);
            const brightness = Math.pow((value_wave + 1) * 0.5, fade_mult);

            let finalRgb;
            if (color_mode === "Rainbow") {
                const hue = (angle + distance + progress * color_mult * color_rotation_speed) % 360;
                finalRgb = hslToRgb(hue, 100, brightness * 50);
            } else { // Custom color mode
                if (!gradientData) continue;
                const color_lookup = (angle + distance + progress * color_mult * color_rotation_speed) % 360 / 360.0;
                const gradIndex = Math.floor(Math.abs(color_lookup) * (gradientCanvas.width - 1)) * 4;
                
                const r = gradientData[gradIndex] * brightness;
                const g = gradientData[gradIndex + 1] * brightness;
                const b = gradientData[gradIndex + 2] * brightness;
                finalRgb = [Math.round(r), Math.round(g), Math.round(b)];
            }

            pixels[pixelIndex] = finalRgb[0];
            pixels[pixelIndex + 1] = finalRgb[1];
            pixels[pixelIndex + 2] = finalRgb[2];
            pixels[pixelIndex + 3] = 255;
        }
    }
    
    ctx.putImageData(imageData, 0, 0);

    requestAnimationFrame(update);
}

// Initial call
requestAnimationFrame(update);

</script>
</html>
