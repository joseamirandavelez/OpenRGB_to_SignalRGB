<!DOCTYPE html><!--Original code: https://gitlab.com/OpenRGBDevelopers/OpenRGBEffectsPlugin/-/tree/master?ref_type=heads-->
<html>
<head>
    <title>ORGB: Mosaic</title>
    <meta description="Tiles randomly spawning across your devices.">
    <meta publisher="Jose Miranda (Port and improvements)">

    <meta property="speed" label="Fade Speed" type="number" min="1" max="200" default="50">
    <meta property="rarity" label="Rarity (higher is rarer)" type="number" min="10" max="2000" default="100">
    <meta property="random_colors" label="Random Colors" type="boolean" default="true">

    <meta property="color1" label="Color 1" type="color" min="0" max="360" default="#ff0000">
    <meta property="color2" label="Color 2" type="color" min="0" max="360" default="#00ff00">
    <meta property="color3" label="Color 3" type="color" min="0" max="360" default="#0000ff">
    <meta property="color4" label="Color 4" type="color" min="0" max="360" default="#ffff00">
</head>

<body style="margin: 0; padding: 0;">
    <canvas id="mosaic-canvas" width="320" height="200"></canvas>
</body>

<script>
// -------------------------------------------------------------------
// SETUP
// -------------------------------------------------------------------

const canvas = document.getElementById('mosaic-canvas');
const ctx = canvas.getContext('2d');
const canvasWidth = canvas.width;
const canvasHeight = canvas.height;
const imageData = ctx.createImageData(canvasWidth, canvasHeight);
const pixels = imageData.data;

// This array will store the state for each pixel ("tile")
let tiles = [];

let lastSpeed = speed;
let lastRarity = rarity;
let lastRandomColors = random_colors;
let lastColor1 = color1;
let lastColor2 = color2;
let lastColor3 = color3;
let lastColor4 = color4;


// -------------------------------------------------------------------
// HELPER FUNCTIONS
// -------------------------------------------------------------------

/** Converts a HEX color string to an HSL object */
function hexToHsl(hex) {
    if (!hex) return { h: 0, s: 0, l: 0 };
    let r = parseInt(hex.slice(1, 3), 16) / 255;
    let g = parseInt(hex.slice(3, 5), 16) / 255;
    let b = parseInt(hex.slice(5, 7), 16) / 255;

    let max = Math.max(r, g, b), min = Math.min(r, g, b);
    let h, s, l = (max + min) / 2;

    if (max === min) {
        h = s = 0; // achromatic
    } else {
        let d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch (max) {
            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
            case g: h = (b - r) / d + 2; break;
            case b: h = (r - g) / d + 4; break;
        }
        h /= 6;
    }
    return { h: h * 360, s: s * 100, l: l * 100 };
}

/** Converts HSL color values to an RGB array. */
function hslToRgb(h, s, l) {
    let r, g, b;
    h = h / 360;
    s = s / 100;
    l = l / 100;

    if (s === 0) {
        r = g = b = l; // achromatic
    } else {
        const hue2rgb = (p, q, t) => {
            if (t < 0) t += 1;
            if (t > 1) t -= 1;
            if (t < 1 / 6) return p + (q - p) * 6 * t;
            if (t < 1 / 2) return q;
            if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
            return p;
        };

        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        const p = 2 * l - q;
        r = hue2rgb(p, q, h + 1 / 3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1 / 3);
    }

    return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
}

function getRandomColor() {
    const userColors = [color1, color2, color3, color4].filter(c => c && c !== "#000000");
    if (random_colors) {
        return { h: Math.random() * 360, s: 100 };
    } else if (userColors.length > 0) {
        return hexToHsl(userColors[Math.floor(Math.random() * userColors.length)]);
    }
    return { h: 0, s: 0, l: 0 }; // Failsafe
}

/** Resets and initializes the state for every pixel */
function resetTiles() {
    tiles = [];
    for (let i = 0; i < canvasWidth * canvasHeight; i++) {
        tiles.push({
            h: 0,       // Hue
            s: 100,     // Saturation
            l: 0,       // Lightness (brightness)
            fade_speed: Math.random() + 1 // Random fade speed for each tile
        });
    }
}

// -------------------------------------------------------------------
// MAIN ANIMATION LOOP
// -------------------------------------------------------------------

let lastTime = 0;
function update(currentTime) {
    const deltaTime = (currentTime - lastTime) / 1000;
    lastTime = currentTime;

    if (isNaN(deltaTime)) {
        requestAnimationFrame(update);
        return;
    }

    // Check for changes in meta properties and re-initialize if needed
    if (tiles.length !== canvasWidth * canvasHeight || speed !== lastSpeed || rarity !== lastRarity ||
        random_colors !== lastRandomColors || color1 !== lastColor1 || color2 !== lastColor2 ||
        color3 !== lastColor3 || color4 !== lastColor4) {
        resetTiles();
        lastSpeed = speed;
        lastRarity = rarity;
        lastRandomColors = random_colors;
        lastColor1 = color1;
        lastColor2 = color2;
        lastColor3 = color3;
        lastColor4 = color4;
    }
    
    // Get the user's color palette
    const userColors = [color1, color2, color3, color4].filter(c => c && c !== "#000000");

    const fade_amount = 0.005 * speed * deltaTime;

    // Update each tile's state and render to ImageData
    for (let i = 0; i < tiles.length; i++) {
        const tile = tiles[i];

        // If a tile has faded out, check if it should re-light
        if (tile.l <= 0) {
            tile.l = 0;
            // A random chance to trigger, controlled by rarity
            if (Math.random() < (1 / rarity)) {
                tile.l = 50; // Re-light the tile to 50% lightness (full color)
                tile.fade_speed = Math.random() + 1; // Assign a new random fade speed
                
                // Assign a new color
                const newColor = getRandomColor();
                tile.h = newColor.h;
                tile.s = newColor.s;
            }
        } else {
            // If the tile is lit, fade it out
            tile.l -= fade_amount * tile.fade_speed;
        }
        
        // Convert HSL to RGB and set the pixel data in the buffer
        const [r, g, b] = hslToRgb(tile.h, tile.s, tile.l);

        const index = i * 4;
        pixels[index] = r;
        pixels[index + 1] = g;
        pixels[index + 2] = b;
        pixels[index + 3] = 255;
    }
    
    // Draw the completed frame to the canvas
    ctx.putImageData(imageData, 0, 0);

    requestAnimationFrame(update);
}

// Initial setup and animation start
resetTiles();
requestAnimationFrame(update);
</script>
</html>
