<!DOCTYPE html>
<html>
<head>
    <title>Motion Points</title>
    <meta description="Multiple points that move in all directions on your devices.">
    <meta publisher="Jose Miranda (Conversion and improvements)">

    <meta property="speed" label="Speed" type="number" min="1" max="200" default="100">
    <meta property="number_of_points" label="Number of Points" type="number" min="1" max="100" default="20">
    <meta property="random_colors" label="Random Colors" type="boolean" default="true">
    <meta property="color1" label="Color 1" type="color" default="#ff0000">
    <meta property="color2" label="Color 2" type="color" default="#0000ff">
</head>

<body style="margin: 0; padding: 0;">
    <canvas id="motionpoints-canvas" width="320" height="200"></canvas>
</body>

<script>
// -------------------------------------------------------------------
// SETUP
// -------------------------------------------------------------------

const canvas = document.getElementById('motionpoints-canvas');
const ctx = canvas.getContext('2d');
const canvasWidth = canvas.width;
const canvasHeight = canvas.height;

// This array will store all the active point objects
let points = [];

// -------------------------------------------------------------------
// COLOR UTILITIES
// -------------------------------------------------------------------

function hexToRgb(hex) {
    if (!hex) return [255, 255, 255];
    const r = parseInt(hex.slice(1, 3), 16);
    const g = parseInt(hex.slice(3, 5), 16);
    const b = parseInt(hex.slice(5, 7), 16);
    return [r, g, b];
}

function randomRgb() {
    return [Math.random() * 255, Math.random() * 255, Math.random() * 255];
}

function applyBrightness(rgb, brightness) {
    return [rgb[0] * brightness, rgb[1] * brightness, rgb[2] * brightness];
}

// -------------------------------------------------------------------
// POINT LOGIC
// -------------------------------------------------------------------

/**
 * Initializes or re-initializes a point's properties.
 * It's given a random direction, speed, color, and starting position at an edge.
 */
function initPoint(point) {
    const userColors = [color1, color2].filter(c => c && c !== "#000000");
    
    point.dir = Math.floor(Math.random() * 4); // 0:Left, 1:Right, 2:Up, 3:Down
    point.speed_mult = Math.random() + 1; // 1.0 to 2.0
    
    if (random_colors) {
        point.color = randomRgb();
    } else if (userColors.length > 0) {
        point.color = hexToRgb(userColors[Math.floor(Math.random() * userColors.length)]);
    } else {
        point.color = [255, 255, 255]; // Failsafe
    }
    
    switch(point.dir) {
        case 0: // LEFT
            point.x = 1.0;
            point.y = Math.random();
            break;
        case 1: // RIGHT
            point.x = 0.0;
            point.y = Math.random();
            break;
        case 2: // UP
            point.x = Math.random();
            point.y = 1.0;
            break;
        case 3: // DOWN
            point.x = Math.random();
            point.y = 0.0;
            break;
    }
}

/**
 * Moves a point based on its direction, speed, and the frame's delta time.
 */
function movePoint(point, delta) {
    switch(point.dir) {
        case 0: point.x -= delta; break; // LEFT
        case 1: point.x += delta; break; // RIGHT
        case 2: point.y -= delta; break; // UP
        case 3: point.y += delta; break; // DOWN
    }
}

/**
 * Checks if a point has moved outside the 0.0-1.0 boundary.
 */
function isPointOut(point) {
    return point.x < 0 || point.y < 0 || point.x > 1 || point.y > 1;
}


// -------------------------------------------------------------------
// MAIN ANIMATION LOOP
// -------------------------------------------------------------------

let lastTime = 0;
function update(currentTime) {
    const deltaTime = (currentTime - lastTime) / 1000;
    lastTime = currentTime;

    if (isNaN(deltaTime)) {
        requestAnimationFrame(update);
        return;
    }

    // --- Update State ---
    
    // Adjust the number of points if the slider changes
    while (points.length < number_of_points) {
        const newPoint = {};
        initPoint(newPoint);
        points.push(newPoint);
    }
    while (points.length > number_of_points) {
        points.pop();
    }
    
    // Move each point and re-initialize it if it goes off-screen
    const move_delta = 0.005 * (speed/10) * deltaTime * 60;
    for (const point of points) {
        movePoint(point, move_delta * point.speed_mult);
        if (isPointOut(point)) {
            initPoint(point);
        }
    }

    // --- Render ---
    ctx.fillStyle = 'black';
    ctx.fillRect(0, 0, canvasWidth, canvasHeight);

    const imageData = ctx.createImageData(canvasWidth, canvasHeight);
    const data = imageData.data;

    // This is more efficient than a getColor function for this effect.
    // We draw each point onto the pixel buffer.
    for (const point of points) {
        const px = point.x * canvasWidth;
        const py = point.y * canvasHeight;
        
        // Only draw pixels in a small box around the point for performance
        const startX = Math.max(0, Math.floor(px - 2));
        const endX = Math.min(canvasWidth, Math.ceil(px + 2));
        const startY = Math.max(0, Math.floor(py - 2));
        const endY = Math.min(canvasHeight, Math.ceil(py + 2));

        for (let y = startY; y < endY; y++) {
            for (let x = startX; x < endX; x++) {
                const distance = Math.sqrt(Math.pow(px - x, 2) + Math.pow(py - y, 2));
                
                // If the pixel is within the point's 1-pixel radius, draw it
                if (distance <= 1) {
                    const brightness = 1 - distance;
                    const finalColor = applyBrightness(point.color, brightness);
                    const index = (y * canvasWidth + x) * 4;
                    
                    // We add to the existing pixel data to blend points that overlap
                    data[index] = Math.min(255, data[index] + finalColor[0]);
                    data[index + 1] = Math.min(255, data[index + 1] + finalColor[1]);
                    data[index + 2] = Math.min(255, data[index + 2] + finalColor[2]);
                    data[index + 3] = 255;
                }
            }
        }
    }
    
    ctx.putImageData(imageData, 0, 0);
    
    requestAnimationFrame(update);
}

// Initial call
requestAnimationFrame(update);

</script>
</html>