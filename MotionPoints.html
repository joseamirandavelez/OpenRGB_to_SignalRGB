<!DOCTYPE html><!--Original code: https://gitlab.com/OpenRGBDevelopers/OpenRGBEffectsPlugin/-/tree/master?ref_type=heads-->
<html>
<head>
    <title>ORGB: Motion Points</title>
    <meta description="Multiple points that move in all directions on your devices.">
    <meta publisher="Jose Miranda (Port and improvements)">

    <meta property="speed" label="Speed" type="number" min="1" max="200" default="100">
    <meta property="number_of_points" label="Number of Points" type="number" min="1" max="100" default="20">
    <meta property="point_size" label="Point Size" type="number" min="1" max="10" default="1">
    <meta property="random_colors" label="Random Colors" type="boolean" default="true">
    <meta property="color1" label="Color 1" type="color" default="#ff0000">
    <meta property="color2" label="Color 2" type="color" default="#0000ff">
</head>

<body style="margin: 0; padding: 0;">
    <canvas id="motionpoints-canvas" width="320" height="200"></canvas>
</body>

<script>
// -------------------------------------------------------------------
// SETUP
// -------------------------------------------------------------------

const canvas = document.getElementById('motionpoints-canvas');
const ctx = canvas.getContext('2d');
const canvasWidth = canvas.width;
const canvasHeight = canvas.height;
const imageData = ctx.createImageData(canvasWidth, canvasHeight);
const pixels = imageData.data;

// This array will store all the active point objects
let points = [];
let lastNumberOfPoints = -1;
let lastRandomColors = false;
let lastColor1 = '';
let lastColor2 = '';
let lastSpeed = -1;
let lastPointSize = -1;


// -------------------------------------------------------------------
// COLOR UTILITIES
// -------------------------------------------------------------------

function hexToRgb(hex) {
    if (!hex) return [255, 255, 255];
    const r = parseInt(hex.slice(1, 3), 16);
    const g = parseInt(hex.slice(3, 5), 16);
    const b = parseInt(hex.slice(5, 7), 16);
    return [r, g, b];
}

function randomRgb() {
    return [Math.random() * 255, Math.random() * 255, Math.random() * 255];
}

function applyBrightness(rgb, brightness) {
    return [rgb[0] * brightness, rgb[1] * brightness, rgb[2] * brightness];
}

// -------------------------------------------------------------------
// POINT LOGIC
// -------------------------------------------------------------------

function getRandomColor() {
    const userColors = [color1, color2].filter(c => c && c !== "#000000");
    if (random_colors) {
        return randomRgb();
    } else if (userColors.length > 0) {
        return hexToRgb(userColors[Math.floor(Math.random() * userColors.length)]);
    }
    return [255, 255, 255]; // Failsafe
}

function initPoint(point) {
    point.speed_mult = Math.random() * 0.5 + 0.5;
    point.color = getRandomColor();
    const dir = Math.floor(Math.random() * 4);

    switch(dir) {
        case 0: // LEFT
            point.x = 1.0;
            point.y = Math.random();
            break;
        case 1: // RIGHT
            point.x = 0.0;
            point.y = Math.random();
            break;
        case 2: // UP
            point.x = Math.random();
            point.y = 1.0;
            break;
        case 3: // DOWN
            point.x = Math.random();
            point.y = 0.0;
            break;
    }
    point.dir = dir;
}

// -------------------------------------------------------------------
// MAIN ANIMATION LOOP
// -------------------------------------------------------------------

let lastTime = 0;
function update(currentTime) {
    const deltaTime = (currentTime - lastTime) / 1000;
    lastTime = currentTime;

    if (isNaN(deltaTime)) {
        requestAnimationFrame(update);
        return;
    }

    // Check for changes in meta properties and re-initialize if needed
    if(number_of_points !== lastNumberOfPoints || random_colors !== lastRandomColors ||
       color1 !== lastColor1 || color2 !== lastColor2 || point_size !== lastPointSize) {
        points = [];
        lastNumberOfPoints = number_of_points;
        lastRandomColors = random_colors;
        lastColor1 = color1;
        lastColor2 = color2;
        lastPointSize = point_size;
    }
    
    // Adjust the number of points if the slider changes
    while (points.length < number_of_points) {
        const newPoint = {};
        initPoint(newPoint);
        points.push(newPoint);
    }
    while (points.length > number_of_points) {
        points.pop();
    }
    
    // Move each point and re-initialize it if it goes off-screen
    const move_delta = 0.005 * (speed/10) * deltaTime * 60;
    for (const point of points) {
        switch(point.dir) {
            case 0: point.x -= move_delta * point.speed_mult; break;
            case 1: point.x += move_delta * point.speed_mult; break;
            case 2: point.y -= move_delta * point.speed_mult; break;
            case 3: point.y += move_delta * point.speed_mult; break;
        }

        if (point.x < 0 || point.y < 0 || point.x > 1 || point.y > 1) {
            initPoint(point);
        }
    }

    // --- Render ---
    for(let i = 0; i < pixels.length; i += 4) {
        pixels[i] = 0;
        pixels[i+1] = 0;
        pixels[i+2] = 0;
        pixels[i+3] = 255;
    }

    for (const point of points) {
        const px = point.x * canvasWidth;
        const py = point.y * canvasHeight;
        
        const size = point_size;

        for (let y = Math.floor(py - size); y < Math.ceil(py + size); y++) {
            for (let x = Math.floor(px - size); x < Math.ceil(px + size); x++) {
                if(x < 0 || x >= canvasWidth || y < 0 || y >= canvasHeight) continue;

                const distance = Math.sqrt(Math.pow(px - x, 2) + Math.pow(py - y, 2));
                
                if (distance <= size) {
                    const brightness = 1 - (distance / size);
                    const finalColor = applyBrightness(point.color, brightness);
                    const index = (y * canvasWidth + x) * 4;
                    
                    pixels[index] = Math.min(255, pixels[index] + Math.round(finalColor[0]));
                    pixels[index + 1] = Math.min(255, pixels[index + 1] + Math.round(finalColor[1]));
                    pixels[index + 2] = Math.min(255, pixels[index + 2] + Math.round(finalColor[2]));
                    pixels[index + 3] = 255;
                }
            }
        }
    }
    
    ctx.putImageData(imageData, 0, 0);
    
    requestAnimationFrame(update);
}

// Initial call
requestAnimationFrame(update);
</script>
</html>
