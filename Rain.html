<!DOCTYPE html>
<html>
<head>
    <title>Rain</title>
    <meta description="Droplet effect.">
    <meta publisher="Jose Miranda (Conversion and improvements)">

    <meta property="speed" label="Speed" type="number" min="1" max="200" default="25">
    <meta property="number_of_drops" label="Drops" type="number" min="1" max="50" default="20">
    <meta property="drop_length" label="Drop Length" type="number" min="1" max="10" default="2">
    <meta property="drop_width" label="Drop Width" type="number" min="1" max="10" default="2">
    <meta property="random_colors" label="Random Colors" type="boolean" default="false">
    
    <meta property="color1" label="Color 1" type="color" default="#0000ff">
    <meta property="color2" label="Color 2" type="color" default="#00ffff">
    <meta property="color3" label="Color 3" type="color" default="#ffffff">
    <meta property="color4" label="Color 4" type="color" default="#00aaff">
    <meta property="color5" label="Color 5" type="color" default="#00007f">
</head>

<body style="margin: 0; padding: 0;">
    <canvas id="rain-canvas" width="320" height="200"></canvas>
</body>

<script>
// -------------------------------------------------------------------
// SETUP
// -------------------------------------------------------------------

const canvas = document.getElementById('rain-canvas');
const ctx = canvas.getContext('2d');
const canvasWidth = canvas.width;
const canvasHeight = canvas.height;

// This array will store all the active drop objects
let drops = [];

// -------------------------------------------------------------------
// COLOR UTILITIES
// -------------------------------------------------------------------

function hexToRgb(hex) {
    if (!hex) return [0, 0, 255];
    const r = parseInt(hex.slice(1, 3), 16);
    const g = parseInt(hex.slice(3, 5), 16);
    const b = parseInt(hex.slice(5, 7), 16);
    return [r, g, b];
}

function randomRgb() {
    return [Math.random() * 255, Math.random() * 255, Math.random() * 255];
}

function applyBrightness(rgb, brightness) {
    return [rgb[0] * brightness, rgb[1] * brightness, rgb[2] * brightness];
}

function lerpColor(c1, c2, factor) {
    const r = c1[0] * (1 - factor) + c2[0] * factor;
    const g = c1[1] * (1 - factor) + c2[1] * factor;
    const b = c1[2] * (1 - factor) + c2[2] * factor;
    return [r, g, b];
}

// -------------------------------------------------------------------
// DROP LOGIC
// -------------------------------------------------------------------

function triggerDrop() {
    const userColors = [color1, color2, color3, color4, color5].filter(c => c && c !== "#000000");
    let color;

    if (random_colors) {
        color = randomRgb();
    } else if (userColors.length > 0) {
        color = hexToRgb(userColors[Math.floor(Math.random() * userColors.length)]);
    } else {
        color = [0, 0, 255]; // Failsafe to blue
    }

    drops.push({
        progress: 0.0,
        color: color,
        col: Math.floor(Math.random() * canvasWidth - drop_width + 1),
        speed_mult: Math.random() * 3 + 1,
        length: drop_length,
        width: drop_width
    });
}

function runDrops(deltaTime) {
    for (const drop of drops) {
        drop.progress += 0.5 * drop.speed_mult * (speed/10) * deltaTime * 60;
    }
}

function cleanDrops() {
    drops = drops.filter(drop => drop.progress <= (canvasHeight + 3 * drop.length));
}

function getColor(x, y) {
    for (const drop of drops) {
        // Check if the current pixel's column matches the drop's full width
        if (x >= drop.col && x < (drop.col + drop.width)) {
            const distance = drop.progress - y;
            const trailLength = (drop.speed_mult - 1) * ((drop.length / 2) + 1);

            if (distance >= 0 && distance <= drop.length + 1 + trailLength) {
                const whole = Math.floor(distance);
                const frac = distance - whole;

                if (whole === 0) { // Head of the drop
                    return applyBrightness(drop.color, frac);
                } else if (whole > 0 && whole <= drop.length) { // Middle of the drop
                    return drop.color;
                } else { // Tail of the drop
                    return lerpColor([0,0,0], drop.color, 0.75 / (whole - drop.length));
                }
            }
        }
    }
    return [0, 0, 0]; // Background is black
}

// -------------------------------------------------------------------
// MAIN ANIMATION LOOP
// -------------------------------------------------------------------

let lastTime = 0;
function update(currentTime) {
    const deltaTime = (currentTime - lastTime) / 1000;
    lastTime = currentTime;

    if (isNaN(deltaTime)) {
        requestAnimationFrame(update);
        return;
    }

    // --- Update State ---
    runDrops(deltaTime);
    cleanDrops();

    // Randomly spawn new drops
    if (drops.length < number_of_drops && Math.random() < 0.2) {
        triggerDrop();
    }
    
    // --- Render ---
    ctx.fillStyle = 'black';
    ctx.fillRect(0, 0, canvasWidth, canvasHeight);

    const imageData = ctx.createImageData(canvasWidth, canvasHeight);
    const data = imageData.data;
    
    for (let y = 0; y < canvasHeight; y++) {
        for (let x = 0; x < canvasWidth; x++) {
            const rgb = getColor(x, y);
            const index = (y * canvasWidth + x) * 4;
            data[index] = rgb[0];
            data[index + 1] = rgb[1];
            data[index + 2] = rgb[2];
            data[index + 3] = 255;
        }
    }
    ctx.putImageData(imageData, 0, 0);
    
    requestAnimationFrame(update);
}

// Initial call
requestAnimationFrame(update);

</script>
</html>