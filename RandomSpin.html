<!DOCTYPE html>
<html>
<head>
    <title>Random Spin</title>
    <meta description="A simple Random Spin for your devices.">
    <meta publisher="Jose Miranda (Conversion and improvements)">

    <meta property="speed" label="Speed" type="number" min="1" max="100" default="50">
    <meta property="color1" label="Color 1" type="color" default="#ff0000">
    <meta property="color2" label="Color 2" type="color" default="#0000ff">
</head>

<body style="margin: 0; padding: 0;">
    <canvas id="randomspin-canvas" width="320" height="200"></canvas>
</body>

<script>
// -------------------------------------------------------------------
// SETUP
// -------------------------------------------------------------------

const canvas = document.getElementById('randomspin-canvas');
const ctx = canvas.getContext('2d');
const canvasWidth = canvas.width;
const canvasHeight = canvas.height;

// Gradient canvas for the spinner's colors
const gradientCanvas = document.createElement('canvas');
gradientCanvas.width = 256; // Gradient resolution
gradientCanvas.height = 1;
const gradientCtx = gradientCanvas.getContext('2d', { willReadFrequently: true });
let gradientData = null; // Will hold the raw pixel data of the gradient

// Effect state variables
let progress = 0.0;
// This effect simulates one spinner for the whole canvas
let spinner = {
    stop_progress: 0,
    progress: 0,
    speed_mult: 1.0,
    dir: true, // true = left, false = right
    stop: true,
    next_time_point: 0
};

// -------------------------------------------------------------------
// HELPER FUNCTIONS
// -------------------------------------------------------------------

/** Generates a random number within a range */
function custom_rand(min, max) {
    return Math.random() * (max - min) + min;
}

/** Pre-renders the specific gradient used by the spinner */
function generateGradient() {
    const grad = gradientCtx.createLinearGradient(0, 0, gradientCanvas.width, 0);
    
    // This specific gradient structure is from the original C++ code
    grad.addColorStop(0.0, color1);
    grad.addColorStop(0.15, color1);
    grad.addColorStop(0.25, color2);
    grad.addColorStop(0.35, color1);
    grad.addColorStop(0.5, color1); // Midpoint for symmetry
    grad.addColorStop(0.65, color1);
    grad.addColorStop(0.75, color2);
    grad.addColorStop(0.85, color1);
    grad.addColorStop(1.0, color1);

    gradientCtx.fillStyle = grad;
    gradientCtx.fillRect(0, 0, gradientCanvas.width, 1);
    gradientData = gradientCtx.getImageData(0, 0, gradientCanvas.width, 1).data;
}

// -------------------------------------------------------------------
// EFFECT LOGIC
// -------------------------------------------------------------------

function getColor(x, w) {
    if (!gradientData) return 'rgb(0,0,0)';

    const current_progress = spinner.stop ? spinner.stop_progress : spinner.progress;
    
    let percent = (x / w) + Math.abs(current_progress);
    percent = percent % 1.0; // Wrap the value between 0.0 and 1.0

    const gradIndex = Math.floor(percent * (gradientCanvas.width - 1)) * 4;

    const r = gradientData[gradIndex];
    const g = gradientData[gradIndex + 1];
    const b = gradientData[gradIndex + 2];
    
    return `rgb(${r}, ${g}, ${b})`;
}

// -------------------------------------------------------------------
// MAIN ANIMATION LOOP
// -------------------------------------------------------------------

let lastTime = 0;
let lastColorSettings = "";
function update(currentTime) {
    const deltaTime = (currentTime - lastTime) / 1000;
    lastTime = currentTime;

    if (isNaN(deltaTime)) {
        requestAnimationFrame(update);
        return;
    }

    // --- Update State ---

    // Regenerate gradient only if the user changes the colors
    const currentSettings = color1 + color2;
    if (currentSettings !== lastColorSettings) {
        generateGradient();
        lastColorSettings = currentSettings;
    }
    
    // Update master progress
    progress += 0.01 * speed * deltaTime;

    // Randomly decide whether to start or stop the spinner
    if (spinner.next_time_point < progress) {
        spinner.stop = !spinner.stop;
        spinner.next_time_point = progress + custom_rand(1, spinner.stop ? 1.5 : 3.5);
        spinner.speed_mult = custom_rand(1.0, 5.0);
        spinner.dir = Math.random() < 0.5;
        spinner.stop_progress = spinner.progress; // Freeze progress when stopping
    }
    
    // Update the spinner's own progress if it's not stopped
    if (!spinner.stop) {
        const direction = spinner.dir ? -1 : 1;
        spinner.progress += direction * spinner.speed_mult * 0.01 * speed * deltaTime;
    }
    
    // --- Render ---
    for (let x = 0; x < canvasWidth; x++) {
        const colColor = getColor(x, canvasWidth);
        ctx.fillStyle = colColor;
        ctx.fillRect(x, 0, 1, canvasHeight);
    }
    
    requestAnimationFrame(update);
}

// Initial call
generateGradient();
requestAnimationFrame(update);

</script>
</html>