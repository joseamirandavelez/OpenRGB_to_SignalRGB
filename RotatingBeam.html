<!DOCTYPE html>
<html>
<head>
    <title>Rotating Beam</title>
    <meta description="A beam that rotates in different ways.">
    <meta publisher="Jose Miranda (Conversion and improvements)">

    <meta property="speed" label="Speed" type="number" min="1" max="100" default="50">
    <meta property="glow" label="Glow" type="number" min="1" max="50" default="10">
    <meta property="thickness" label="Thickness" type="number" min="0" max="100" default="5">
    <meta property="mode" label="Mode" type="list" values="Clockwise,Counter Clockwise,Pendulum,Wipers,Swing H,Swing V" default="Clockwise">
    <meta property="random_colors" label="Random Colors" type="boolean" default="false">
    <meta property="color1" label="Beam Color" type="color" default="#ff0000">
    <meta property="color2"label="Background Color" type="color" default="#0000ff">
</head>

<body style="margin: 0; padding: 0;">
    <canvas id="rotatingbeam-canvas" width="320" height="200"></canvas>
</body>

<script>
// -------------------------------------------------------------------
// SETUP
// -------------------------------------------------------------------

const canvas = document.getElementById('rotatingbeam-canvas');
const ctx = canvas.getContext('2d');
const canvasWidth = canvas.width;
const canvasHeight = canvas.height;

// Effect state variables
let progress = 0.0;
let hsv1 = { h: 0, s: 1, v: 1 };
let hsv2 = { h: 180, s: 1, v: 1 };

// -------------------------------------------------------------------
// COLOR UTILITIES
// -------------------------------------------------------------------

function hexToHsv(hex) {
    if (!hex) return { h: 0, s: 0, v: 1 };
    let r = parseInt(hex.slice(1, 3), 16) / 255;
    let g = parseInt(hex.slice(3, 5), 16) / 255;
    let b = parseInt(hex.slice(5, 7), 16) / 255;

    let max = Math.max(r, g, b), min = Math.min(r, g, b);
    let h, s, v = max;
    let d = max - min;
    s = max === 0 ? 0 : d / max;

    if (max === min) { h = 0; } 
    else {
        switch (max) {
            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
            case g: h = (b - r) / d + 2; break;
            case b: h = (r - g) / d + 4; break;
        }
        h /= 6;
    }
    return { h: h * 360, s: s, v: v };
}

function hsvToRgb(h, s, v) {
    let r, g, b;
    const i = Math.floor(h * 6); const f = h * 6 - i;
    const p = v * (1 - s); const q = v * (1 - f * s); const t = v * (1 - (1 - f) * s);
    switch (i % 6) {
        case 0: r = v, g = t, b = p; break; case 1: r = q, g = v, b = p; break;
        case 2: r = p, g = v, b = t; break; case 3: r = p, g = q, b = v; break;
        case 4: r = t, g = p, b = v; break; case 5: r = v, g = p, b = q; break;
    }
    return [r * 255, g * 255, b * 255];
}

function lerpColor(c1, c2, f) {
    return [
        c1[0] * (1 - f) + c2[0] * f,
        c1[1] * (1 - f) + c2[1] * f,
        c1[2] * (1 - f) + c2[2] * f
    ];
}

// -------------------------------------------------------------------
// EFFECT LOGIC
// -------------------------------------------------------------------

/** Calculates the start and end points of the beam for the current frame */
function getBeamEndpoints() {
    let p1 = { x: 0, y: 0 }, p2 = { x: 1, y: 1 };
    switch(mode) {
        case "Clockwise": {
            const x = 0.5 * (1 + Math.cos(progress));
            const y = 0.5 * (1 + Math.sin(progress));
            p1 = { x: x, y: y }; p2 = { x: 1 - x, y: 1 - y };
            break;
        }
        case "Counter Clockwise": {
            const x = 0.5 * (1 + Math.cos(-progress));
            const y = 0.5 * (1 + Math.sin(-progress));
            p1 = { x: x, y: y }; p2 = { x: 1 - x, y: 1 - y };
            break;
        }
        case "Pendulum": {
            const x = 0.5 * (1 + Math.cos(progress));
            p1 = { x: 0.5, y: 0 }; p2 = { x: x, y: 1 };
            break;
        }
        case "Wipers": {
            const x = 0.5 * (1 + Math.cos(progress));
            p1 = { x: x, y: 0 }; p2 = { x: 0.5, y: 1 };
            break;
        }
        case "Swing H": {
            const x = 0.5 * (1 + Math.cos(progress));
            p1 = { x: 0, y: x }; p2 = { x: 1, y: 1 - x };
            break;
        }
        case "Swing V": {
            const x = 0.5 * (1 + Math.cos(progress));
            p1 = { x: x, y: 0 }; p2 = { x: 1 - x, y: 1 };
            break;
        }
    }
    return { p1, p2 };
}

function getColor(x, y, w, h, beam) {
    // Convert beam endpoints from normalized (0-1) to canvas coordinates
    const x1 = beam.p1.x * w, y1 = beam.p1.y * h;
    const x2 = beam.p2.x * w, y2 = beam.p2.y * h;
    
    // Calculate the perpendicular distance from the pixel (x,y) to the beam line
    const dx = x2 - x1, dy = y2 - y1;
    const distance = Math.abs(dx * (y1 - y) - (x1 - x) * dy) / Math.sqrt(dx*dx + dy*dy);
    
    // Calculate brightness (value) based on distance, thickness, and glow
    const max_dist = 0.5 * (w + h);
    const value = hsv1.v - hsv1.v * Math.pow(distance / max_dist, distance < thickness ? 1 : (glow / 100.0));
    
    const color1_rgb = hsvToRgb(hsv1.h, hsv1.s * 100, value);
    const color2_rgb = hsvToRgb(hsv2.h, hsv2.s * 100, hsv2.v * 100);

    // Interpolate between the background and the beam color
    const final_color = lerpColor(color2_rgb, color1_rgb, 1 - (distance / max_dist));

    return `rgb(${final_color[0]}, ${final_color[1]}, ${final_color[2]})`;
}

// -------------------------------------------------------------------
// MAIN ANIMATION LOOP
// -------------------------------------------------------------------

let lastTime = 0;
let lastColor1 = "", lastColor2 = "";
function update(currentTime) {
    const deltaTime = (currentTime - lastTime) / 1000;
    lastTime = currentTime;

    if (isNaN(deltaTime)) {
        requestAnimationFrame(update);
        return;
    }

    progress += 0.1 * speed * deltaTime;

    // Update colors
    if (random_colors) {
        hsv1.h = (hsv1.h + 0.5) % 360;
        hsv2.h = (hsv2.h + 0.5) % 360;
    } else {
        if(color1 !== lastColor1) { hsv1 = hexToHsv(color1); lastColor1 = color1; }
        if(color2 !== lastColor2) { hsv2 = hexToHsv(color2); lastColor2 = color2; }
    }

    const beam = getBeamEndpoints();
    
    // Render
    for (let y = 0; y < canvasHeight; y++) {
        for (let x = 0; x < canvasWidth; x++) {
            ctx.fillStyle = getColor(x, y, canvasWidth, canvasHeight, beam);
            ctx.fillRect(x, y, 1, 1);
        }
    }
    
    requestAnimationFrame(update);
}

// Initial call
requestAnimationFrame(update);

</script>
</html>