<!DOCTYPE html><!--Original code: https://gitlab.com/OpenRGBDevelopers/OpenRGBEffectsPlugin/-/tree/master?ref_type=heads-->
<html>
<head>
    <title>ORGB: Sequence</title>
    <meta description="Alternates colors with a fade effect.">
    <meta publisher="Jose Miranda (Port and improvements)">

    <meta property="speed" label="Speed" type="number" min="1" max="20" default="10">
    <meta property="fade_time" label="Fade Time" type="number" min="1" max="100" default="50">
    
    <meta property="color1" label="Color 1" type="color" min="0" max="360" default="#ff0000">
    <meta property="color2" label="Color 2" type="color" min="0" max="360" default="#00ff00">
    <meta property="color3" label="Color 3" type="color" min="0" max="360" default="#0000ff">
    <meta property="color4" label="Color 4" type="color" min="0" max="360" default="#ffff00">
    <meta property="color5" label="Color 5" type="color" min="0" max="360" default="#000000">
    <meta property="color6" label="Color 6" type="color" min="0" max="360" default="#000000">
    <meta property="color7" label="Color 7" type="color" min="0" max="360" default="#000000">
    <meta property="color8" label="Color 8" type="color" min="0" max="360" default="#000000">
</head>

<body style="margin: 0; padding: 0;">
    <canvas id="sequence-canvas" width="320" height="200"></canvas>
</body>

<script>
// -------------------------------------------------------------------
// SETUP
// -------------------------------------------------------------------

const canvas = document.getElementById('sequence-canvas');
const ctx = canvas.getContext('2d');
const canvasWidth = canvas.width;
const canvasHeight = canvas.height;

// Effect state variables
let progress = 0.0;
let lastColors = [];
let lastSpeed = speed;
let lastFadeTime = fade_time;

// -------------------------------------------------------------------
// COLOR UTILITIES
// -------------------------------------------------------------------

function hexToRgb(hex) {
    if (!hex) return [0, 0, 0];
    const r = parseInt(hex.slice(1, 3), 16);
    const g = parseInt(hex.slice(3, 5), 16);
    const b = parseInt(hex.slice(5, 7), 16);
    return [r, g, b];
}

/** Linearly interpolates between two colors */
function lerpColor(c1, c2, factor) {
    const r = c1[0] * (1 - factor) + c2[0] * factor;
    const g = c1[1] * (1 - factor) + c2[1] * factor;
    const b = c1[2] * (1 - factor) + c2[2] * factor;
    return [r, g, b];
}

// -------------------------------------------------------------------
// MAIN ANIMATION LOOP
// -------------------------------------------------------------------

let lastTime = 0;
function update(currentTime) {
    const deltaTime = (currentTime - lastTime) / 1000;
    lastTime = currentTime;

    if (isNaN(deltaTime)) {
        requestAnimationFrame(update);
        return;
    }
    
    // Check for changes in meta properties and update colors
    const currentMetaColors = [color1, color2, color3, color4, color5, color6, color7, color8];
    const newColors = currentMetaColors
        .filter(c => c && c !== "#000000")
        .map(hexToRgb);

    if (JSON.stringify(newColors) !== JSON.stringify(lastColors) || speed !== lastSpeed || fade_time !== lastFadeTime) {
        lastColors = newColors;
        lastSpeed = speed;
        lastFadeTime = fade_time;
        progress = 0.0; // Restart animation on change
    }

    if (lastColors.length === 0) {
        ctx.fillStyle = 'black';
        ctx.fillRect(0, 0, canvasWidth, canvasHeight);
        requestAnimationFrame(update);
        return;
    }
    
    // --- Update State ---
    const color_count = lastColors.length;
    const current_color_index = Math.floor(progress) % color_count;
    const frac = progress % 1.0;

    let final_color;
    
    const fade_threshold = fade_time / 100.0;
    const hold_duration = 1.0 - fade_threshold;

    if (frac >= hold_duration) {
       const next_color_index = (current_color_index + 1) % color_count;
       const fade_progress = (frac - hold_duration) / fade_threshold;
       final_color = lerpColor(lastColors[current_color_index], lastColors[next_color_index], fade_progress);
    } else {
        final_color = lastColors[current_color_index];
    }
    
    const increment = (speed / 10.0) * deltaTime;
    progress += increment;

    // --- Render ---
    ctx.fillStyle = `rgb(${Math.round(final_color[0])}, ${Math.round(final_color[1])}, ${Math.round(final_color[2])})`;
    ctx.fillRect(0, 0, canvasWidth, canvasHeight);
    
    requestAnimationFrame(update);
}

// Initial call
requestAnimationFrame(update);

</script>
</html>
