<!DOCTYPE html>
<html>
<head>
    <title>ORGB: Smooth Blink</title>
    <meta description="Create your own breathing sequences.">
    <meta publisher="Jose Miranda (Conversion and improvements)">

    <meta property="rendering_mode" label="Rendering" type="list" values="Solid,Circle" default="Solid">
    <meta property="interval" label="Interval (s)" type="number" min="1" max="10" default="2">
    <meta property="pulses" label="Pulses" type="number" min="1" max="200" default="2">
    <meta property="pulse_duration" label="Pulse Duration (ms)" type="number" min="100" max="1000" step="1" default="100">
    <meta property="strength" label="Strength (%)" type="number" min="0" max="100" default="50">
    <meta property="center_x" label="X Position (%)" type="number" min="0" max="100" default="50">
    <meta property="center_y" label="Y Position (%)" type="number" min="0" max="100" default="50">
    <meta property="random_colors" label="Random Colors" type="boolean" default="false">
    <meta property="color1" label="Color 1 (Pulse)" type="color" default="#ff0000">
    <meta property="color2" label="Color 2 (Base)" type="color" default="#0000ff">
</head>

<body style="margin: 0; padding: 0;">
    <canvas id="smoothblink-canvas" width="320" height="200"></canvas>
</body>

<script>
// -------------------------------------------------------------------
// SETUP
// -------------------------------------------------------------------

const canvas = document.getElementById('smoothblink-canvas');
const ctx = canvas.getContext('2d');
const canvasWidth = canvas.width;
const canvasHeight = canvas.height;
const imageData = ctx.createImageData(canvasWidth, canvasHeight);
const pixels = imageData.data;

// Effect state variables
let time = 0.0;
let random_fade_timer = 0.0;
let random_color_1 = [255, 0, 0], next_color_1 = [0, 255, 0];
let random_color_2 = [0, 0, 255], next_color_2 = [255, 255, 0];
let current_color_1 = [255, 0, 0], current_color_2 = [0, 0, 255];
let last_random_colors_state = false;

// -------------------------------------------------------------------
// COLOR UTILITIES
// -------------------------------------------------------------------

function hexToRgb(hex) {
    if (!hex) return [0, 0, 0];
    return [parseInt(hex.slice(1, 3), 16), parseInt(hex.slice(3, 5), 16), parseInt(hex.slice(5, 7), 16)];
}

function randomRgb() {
    return [Math.random() * 255, Math.random() * 255, Math.random() * 255];
}

function lerpColor(c1, c2, f) {
    return [
        c1[0] * (1 - f) + c2[0] * f,
        c1[1] * (1 - f) + c2[1] * f,
        c1[2] * (1 - f) + c2[2] * f
    ];
}

function clampColor(color) {
    return [
        Math.min(255, Math.max(0, Math.round(color[0]))),
        Math.min(255, Math.max(0, Math.round(color[1]))),
        Math.min(255, Math.max(0, Math.round(color[2])))
    ];
}

// -------------------------------------------------------------------
// MAIN ANIMATION LOOP
// -------------------------------------------------------------------

let lastTime = 0;
function update(currentTime) {
    const deltaTime = (currentTime - lastTime) / 1000;
    lastTime = currentTime;

    // Correct the time variable if it's NaN
    if (isNaN(time)) {
        time = 0.0;
    }
    
    // --- Update State ---
    
    // Check for random_colors state change
    if (random_colors && !last_random_colors_state) {
        random_color_1 = hexToRgb(color1);
        next_color_1 = randomRgb();
        random_color_2 = hexToRgb(color2);
        next_color_2 = randomRgb();
        random_fade_timer = 0;
    }
    last_random_colors_state = random_colors;

    // Update colors
    if (random_colors) {
        if (random_fade_timer < 0.5 * interval) {
            const factor = random_fade_timer / (0.5 * interval);
            current_color_1 = lerpColor(random_color_1, next_color_1, factor);
            current_color_2 = lerpColor(random_color_2, next_color_2, factor);
        } else {
            current_color_1 = next_color_1;
            current_color_2 = next_color_2;
        }
    } else {
        current_color_1 = hexToRgb(color1);
        current_color_2 = hexToRgb(color2);
    }
    
    // Calculate pulse state
    const pulses_total_duration = pulses * pulse_duration/1000;
    const total_effect_duration = interval + pulses_total_duration;
    
    let pulse_value;

    // Handle case where total_effect_duration is zero
    if (total_effect_duration === 0) {
        pulse_value = 0.5; // A neutral value to prevent errors
    } else if (time < interval) {
        pulse_value = 1.0;
    } else {
        const x = (time - interval) % pulses_total_duration;
        const pulse_frequency = pulses / pulses_total_duration;
        pulse_value = 0.5 + 0.5 * Math.sin(Math.PI * 2 * pulse_frequency * x - Math.PI * 0.5);
        pulse_value = Math.max(0, Math.min(1, pulse_value));
    }
    
    time += deltaTime;
    random_fade_timer += deltaTime;

    if (time >= total_effect_duration && total_effect_duration > 0) {
        time %= total_effect_duration;
        next_color_1 = randomRgb();
        next_color_2 = randomRgb();
        random_fade_timer = 0;
    }

    // --- Render ---
    if (rendering_mode === "Solid") {
        const final_color = clampColor(lerpColor(current_color_1, current_color_2, pulse_value));
        ctx.fillStyle = `rgb(${final_color[0]}, ${final_color[1]}, ${final_color[2]})`;
        ctx.fillRect(0, 0, canvasWidth, canvasHeight);
    } else { // Circle mode
        for (let i = 0; i < pixels.length; i += 4) {
            pixels[i] = 0;
            pixels[i + 1] = 0;
            pixels[i + 2] = 0;
            pixels[i + 3] = 255;
        }
        
        const centerX = canvasWidth * (center_x / 100.0);
        const centerY = canvasHeight * (center_y / 100.0);
        const max_dist = Math.sqrt(Math.pow(canvasWidth/2, 2) + Math.pow(canvasHeight/2, 2));

        for (let y = 0; y < canvasHeight; y++) {
            for (let x = 0; x < canvasWidth; x++) {
                const pixelIndex = (y * canvasWidth + x) * 4;

                const distance = Math.sqrt(Math.pow(centerX - x, 2) + Math.pow(centerY - y, 2));
                const distance_percent = distance / max_dist;
                
                const factor = Math.min(1.0, pulse_value + distance_percent * ((100 - strength) / 100));

                const final_color = clampColor(lerpColor(current_color_1, current_color_2, factor));
                
                pixels[pixelIndex] = final_color[0];
                pixels[pixelIndex + 1] = final_color[1];
                pixels[pixelIndex + 2] = final_color[2];
                pixels[pixelIndex + 3] = 255;
            }
        }
        ctx.putImageData(imageData, 0, 0);
    }
    
    requestAnimationFrame(update);
}

// Initial call
requestAnimationFrame(update);
</script>
</html>