<!DOCTYPE html>
<html>
<head>
    <title>Smooth Blink</title>
    <meta description="Create your own breathing sequences.">
    <meta publisher="Jose Miranda (Conversion and improvements)">

    <meta property="rendering_mode" label="Rendering" type="list" values="Solid,Circle" default="Solid">
    <meta property="interval" label="Interval (s)" type="number" min="0.1" max="10.0" step="0.1" default="2.0">
    <meta property="pulses" label="Pulses" type="number" min="1" max="200" default="2">
    <meta property="pulse_duration" label="Pulse Duration (s)" type="number" min="0.1" max="10.0" step="0.1" default="0.5">
    <meta property="strength" label="Strength (%)" type="number" min="0" max="100" default="50">
    <meta property="center_x" label="X Position (%)" type="number" min="0" max="100" default="50">
    <meta property="center_y" label="Y Position (%)" type="number" min="0" max="100" default="50">
    <meta property="random_colors" label="Random Colors" type="boolean" default="false">
    <meta property="color1" label="Color 1 (Pulse)" type="color" default="#ff0000">
    <meta property="color2" label="Color 2 (Base)" type="color" default="#0000ff">
</head>

<body style="margin: 0; padding: 0;">
    <canvas id="smoothblink-canvas" width="320" height="200"></canvas>
</body>

<script>
// -------------------------------------------------------------------
// SETUP
// -------------------------------------------------------------------

const canvas = document.getElementById('smoothblink-canvas');
const ctx = canvas.getContext('2d');
const canvasWidth = canvas.width;
const canvasHeight = canvas.height;

// Effect state variables
let time = 0.0;
let random_fade_timer = 0.0;
let random_color_1 = [255, 0, 0], next_color_1 = [0, 255, 0];
let random_color_2 = [0, 0, 255], next_color_2 = [255, 255, 0];
let current_color_1 = [255, 0, 0], current_color_2 = [0, 0, 255];

// -------------------------------------------------------------------
// COLOR UTILITIES
// -------------------------------------------------------------------

function hexToRgb(hex) {
    if (!hex) return [0, 0, 0];
    return [parseInt(hex.slice(1, 3), 16), parseInt(hex.slice(3, 5), 16), parseInt(hex.slice(5, 7), 16)];
}

function randomRgb() {
    return [Math.random() * 255, Math.random() * 255, Math.random() * 255];
}

function lerpColor(c1, c2, f) {
    return [
        c1[0] * (1 - f) + c2[0] * f,
        c1[1] * (1 - f) + c2[1] * f,
        c1[2] * (1 - f) + c2[2] * f
    ];
}

// -------------------------------------------------------------------
// EFFECT LOGIC
// -------------------------------------------------------------------

function getCircleColor(x, y, w, h, pulse_value) {
    const centerX = w * (center_x / 100.0);
    const centerY = h * (center_y / 100.0);
    const max_dist = Math.sqrt(Math.pow(w/2, 2) + Math.pow(h/2, 2));
    
    if (pulse_value >= 1.0) {
        return `rgb(${current_color_2[0]}, ${current_color_2[1]}, ${current_color_2[2]})`;
    }

    const distance = Math.sqrt(Math.pow(centerX - x, 2) + Math.pow(centerY - y, 2));
    const distance_percent = distance / max_dist;
    
    const final_color = lerpColor(current_color_1, current_color_2, Math.min(1.0, pulse_value + distance_percent));
    return `rgb(${final_color[0]}, ${final_color[1]}, ${final_color[2]})`;
}

// -------------------------------------------------------------------
// MAIN ANIMATION LOOP
// -------------------------------------------------------------------

let lastTime = 0;
function update(currentTime) {
    const deltaTime = (currentTime - lastTime) / 1000;
    lastTime = currentTime;

    if (isNaN(deltaTime)) {
        requestAnimationFrame(update);
        return;
    }

    // --- Update State ---

    // Update colors
    if (random_colors) {
        if (random_fade_timer <= 0.5 * interval) {
            const factor = random_fade_timer / (0.5 * interval);
            current_color_1 = lerpColor(random_color_1, next_color_1, factor);
            current_color_2 = lerpColor(random_color_2, next_color_2, factor);
        } else {
            random_color_1 = next_color_1;
            random_color_2 = next_color_2;
        }
    } else {
        current_color_1 = hexToRgb(color1);
        current_color_2 = hexToRgb(color2);
    }
    
    // Calculate pulse state
    const pulses_total_duration = pulses * pulse_duration;
    const total_effect_duration = interval + pulses_total_duration;
    const strength_norm = 0.5 + ((100-strength) / 100.0) * 0.5;

    let pulse_value;
    if (time < interval) {
        // We are in the solid interval phase
        pulse_value = 1.0;
    } else {
        // We are in the pulsing phase
        const x = time - interval;
        const y = 0.5 * (1 + Math.sin((2 * pulses / pulses_total_duration) * x * Math.PI - 0.5 * Math.PI));
        pulse_value = y - (y - strength_norm) / strength_norm;
    }
    
    time += deltaTime;
    random_fade_timer += deltaTime;

    if (time >= total_effect_duration) {
        time %= total_effect_duration;
        next_color_1 = randomRgb();
        next_color_2 = randomRgb();
        random_fade_timer = 0;
    }

    // --- Render ---
    if (rendering_mode === "Solid") {
        const final_color = lerpColor(current_color_1, current_color_2, pulse_value);
        ctx.fillStyle = `rgb(${final_color[0]}, ${final_color[1]}, ${final_color[2]})`;
        ctx.fillRect(0, 0, canvasWidth, canvasHeight);
    } else { // Circle mode
        for (let y = 0; y < canvasHeight; y++) {
            for (let x = 0; x < canvasWidth; x++) {
                ctx.fillStyle = getCircleColor(x, y, canvasWidth, canvasHeight, pulse_value);
                ctx.fillRect(x, y, 1, 1);
            }
        }
    }
    
    requestAnimationFrame(update);
}

// Initial call
requestAnimationFrame(update);

</script>
</html>