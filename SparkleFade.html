<!DOCTYPE html>
<html>
<head>
    <title>Sparkle Fade</title>
    <meta description="Fading in and fade out with sparkles.">
    <meta publisher="Jose Miranda (Conversion and improvements)">

    <meta property="off_time" label="Off Time (ms)" type="number" min="0" max="100000" step="100" default="500">
    <meta property="fade_in_time" label="Fade In Time (ms)" type="number" min="1" max="100000" step="100" default="3000">
    <meta property="fade_out_time" label="Fade Out Time (ms)" type="number" min="1" max="100000" step="100" default="10000">
    <meta property="random_colors" label="Random Colors" type="boolean" default="true">
    <meta property="user_color" label="Color" type="color" default="#ffffff">
</head>

<body style="margin: 0; padding: 0;">
    <canvas id="sparklefade-canvas" width="320" height="200"></canvas>
</body>

<script>
// -------------------------------------------------------------------
// SETUP
// -------------------------------------------------------------------

const canvas = document.getElementById('sparklefade-canvas');
const ctx = canvas.getContext('2d');
const canvasWidth = canvas.width;
const canvasHeight = canvas.height;

// Effect state variables
let currentState = "off"; // off, fadeIn, on, fadeOut
let state_timer = 0;
let baseColor = [255, 255, 255];
let ledInfo = []; // Stores the state for each pixel

// -------------------------------------------------------------------
// COLOR UTILITIES
// -------------------------------------------------------------------

function hexToRgb(hex) {
    if (!hex) return [255, 255, 255];
    return [parseInt(hex.slice(1, 3), 16), parseInt(hex.slice(3, 5), 16), parseInt(hex.slice(5, 7), 16)];
}

function randomRgb() {
    return [Math.random() * 255, Math.random() * 255, Math.random() * 255];
}

function lerpColor(c1, c2, f) {
    return [
        c1[0] * (1 - f) + c2[0] * f,
        c1[1] * (1 - f) + c2[1] * f,
        c1[2] * (1 - f) + c2[2] * f
    ];
}

// -------------------------------------------------------------------
// EFFECT STATE MANAGEMENT
// -------------------------------------------------------------------

function resetLedInfo() {
    ledInfo = [];
    for(let i=0; i < canvasWidth * canvasHeight; i++) {
        ledInfo.push({
            color: [0,0,0],
            fadeStartTime: 0,
            fadeDuration: 0
        });
    }
}

// -------------------------------------------------------------------
// MAIN ANIMATION LOOP
// -------------------------------------------------------------------

let lastTime = 0;
function update(currentTime) {
    const deltaTime = (currentTime - lastTime); // in milliseconds
    lastTime = currentTime;

    if (isNaN(deltaTime)) {
        requestAnimationFrame(update);
        return;
    }
    
    // Ensure our state array matches the canvas size
    if (ledInfo.length !== canvasWidth * canvasHeight) {
        resetLedInfo();
    }
    
    state_timer += deltaTime;

    // --- State Machine ---
    if (currentState === "off") {
        if (state_timer >= off_time) {
            currentState = "fadeIn";
            state_timer = 0;
            baseColor = random_colors ? randomRgb() : hexToRgb(user_color);
        }
    } 
    else if (currentState === "fadeIn") {
        if (state_timer >= fade_in_time) {
            currentState = "on";
            state_timer = 0;
        }
    }
    else if (currentState === "on") {
        // This state is transitional. It runs once to set up the random fade times for the next state.
        for (let i = 0; i < ledInfo.length; i++) {
            ledInfo[i].fadeStartTime = currentTime + (Math.random() * fade_out_time / 2);
            ledInfo[i].fadeDuration = (Math.random() * fade_out_time / 2) + (fade_out_time / 2);
        }
        currentState = "fadeOut";
        state_timer = 0;
    }
    else if (currentState === "fadeOut") {
        let allFaded = true;
        for (let i = 0; i < ledInfo.length; i++) {
            if (ledInfo[i].color[0] > 0 || ledInfo[i].color[1] > 0 || ledInfo[i].color[2] > 0) {
                allFaded = false;
                break;
            }
        }
        if (allFaded) {
            currentState = "off";
            state_timer = 0;
        }
    }
    
    // --- Render ---
    const imageData = ctx.createImageData(canvasWidth, canvasHeight);
    const data = imageData.data;

    for (let i = 0; i < ledInfo.length; i++) {
        let finalColor = [0,0,0];
        if (currentState === "fadeIn") {
            const factor = Math.min(1.0, state_timer / fade_in_time);
            finalColor = lerpColor([0,0,0], baseColor, factor);
        } else if (currentState === "fadeOut") {
            const led = ledInfo[i];
            if(currentTime >= led.fadeStartTime) {
                const factor = Math.min(1.0, (currentTime - led.fadeStartTime) / led.fadeDuration);
                finalColor = lerpColor(baseColor, [0,0,0], factor);
                led.color = finalColor; // Update state for completion check
            } else {
                finalColor = baseColor;
            }
        } else if (currentState === "on") {
            finalColor = baseColor;
        }
        
        const index = i * 4;
        data[index] = finalColor[0];
        data[index + 1] = finalColor[1];
        data[index + 2] = finalColor[2];
        data[index + 3] = 255;
    }
    ctx.putImageData(imageData, 0, 0);

    requestAnimationFrame(update);
}

// Initial call
requestAnimationFrame(update);

</script>
</html>