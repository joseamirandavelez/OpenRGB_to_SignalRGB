<!DOCTYPE html><!--Original code: https://gitlab.com/OpenRGBDevelopers/OpenRGBEffectsPlugin/-/tree/master?ref_type=heads-->
<html>
<head>
    <title>ORGB: Sparkle Fade</title>
    <meta description="Fading in and fade out with sparkles.">
    <meta publisher="Jose Miranda (Port and improvements)">

    <meta property="off_time" label="Off Time (ms)" type="number" min="0" max="100000" step="100" default="500">
    <meta property="fade_in_time" label="Fade In Time (ms)" type="number" min="1" max="100000" step="100" default="3000">
    <meta property="fade_out_time" label="Fade Out Time (ms)" type="number" min="1" max="100000" step="100" default="10000">
    <meta property="random_colors" label="Random Colors" type="boolean" default="true">
    <meta property="user_color" label="Color" type="color" default="#ffffff">
</head>

<body style="margin: 0; padding: 0;">
    <canvas id="sparklefade-canvas" width="320" height="200"></canvas>
</body>

<script>
// -------------------------------------------------------------------
// SETUP
// -------------------------------------------------------------------

const canvas = document.getElementById('sparklefade-canvas');
const ctx = canvas.getContext('2d');
const canvasWidth = canvas.width;
const canvasHeight = canvas.height;
const imageData = ctx.createImageData(canvasWidth, canvasHeight);
const pixels = imageData.data;

// Effect state variables
let currentState = "off"; // off, fadeIn, on, fadeOut
let state_timer = 0;
let baseColor = [255, 255, 255];
let ledInfo = []; // Stores the state for each pixel
let lastRandomColors = random_colors;
let lastUserColor = user_color;

// -------------------------------------------------------------------
// COLOR UTILITIES
// -------------------------------------------------------------------

function hexToRgb(hex) {
    if (!hex) return [255, 255, 255];
    return [parseInt(hex.slice(1, 3), 16), parseInt(hex.slice(3, 5), 16), parseInt(hex.slice(5, 7), 16)];
}

function randomRgb() {
    return [Math.random() * 255, Math.random() * 255, Math.random() * 255];
}

function lerpColor(c1, c2, f) {
    return [
        c1[0] * (1 - f) + c2[0] * f,
        c1[1] * (1 - f) + c2[1] * f,
        c1[2] * (1 - f) + c2[2] * f
    ];
}

// -------------------------------------------------------------------
// EFFECT STATE MANAGEMENT
// -------------------------------------------------------------------

function resetLedInfo() {
    ledInfo = [];
    for(let i=0; i < canvasWidth * canvasHeight; i++) {
        ledInfo.push({
            color: [0,0,0],
            fadeStartTime: 0,
            fadeDuration: 0,
            fading: false
        });
    }
}

// -------------------------------------------------------------------
// MAIN ANIMATION LOOP
// -------------------------------------------------------------------

let lastTime = 0;
function update(currentTime) {
    const deltaTime = (currentTime - lastTime); // in milliseconds
    lastTime = currentTime;

    if (isNaN(deltaTime)) {
        requestAnimationFrame(update);
        return;
    }
    
    if (ledInfo.length !== canvasWidth * canvasHeight) {
        resetLedInfo();
    }
    
    state_timer += deltaTime;

    // --- State Machine ---
    if (currentState === "off") {
        if (state_timer >= off_time) {
            currentState = "fadeIn";
            state_timer = 0;
            // Set new color at the beginning of each cycle
            baseColor = random_colors ? randomRgb() : hexToRgb(user_color);
        }
    } 
    else if (currentState === "fadeIn") {
        if (state_timer >= fade_in_time) {
            currentState = "on";
            state_timer = 0;
        }
    }
    else if (currentState === "on") {
        let allFadedOut = true;
        for (let i = 0; i < ledInfo.length; i++) {
            if (!ledInfo[i].fading) {
                ledInfo[i].fadeStartTime = currentTime + (Math.random() * fade_out_time / 2);
                ledInfo[i].fadeDuration = (Math.random() * fade_out_time / 2) + (fade_out_time / 2);
                ledInfo[i].fading = true;
            }
            if (ledInfo[i].color[0] > 0 || ledInfo[i].color[1] > 0 || ledInfo[i].color[2] > 0) {
                allFadedOut = false;
            }
        }
        if (allFadedOut) {
            currentState = "off";
            state_timer = 0;
            // Clear fading state for the next cycle
            for (let i = 0; i < ledInfo.length; i++) {
                ledInfo[i].fading = false;
            }
        }
    }

    // --- Render ---
    for(let i = 0; i < pixels.length; i += 4) {
        pixels[i] = 0;
        pixels[i+1] = 0;
        pixels[i+2] = 0;
        pixels[i+3] = 255;
    }

    if (currentState === "fadeIn") {
        const factor = Math.min(1.0, state_timer / fade_in_time);
        const finalColor = lerpColor([0,0,0], baseColor, factor);
        for(let i = 0; i < pixels.length; i += 4) {
            pixels[i] = Math.round(finalColor[0]);
            pixels[i+1] = Math.round(finalColor[1]);
            pixels[i+2] = Math.round(finalColor[2]);
        }
    } else if (currentState === "on") {
        for(let i = 0; i < pixels.length; i += 4) {
            pixels[i] = Math.round(baseColor[0]);
            pixels[i+1] = Math.round(baseColor[1]);
            pixels[i+2] = Math.round(baseColor[2]);
        }
    } else if (currentState === "fadeOut") {
        for (let i = 0; i < ledInfo.length; i++) {
            const led = ledInfo[i];
            let finalColor;
            if(currentTime >= led.fadeStartTime) {
                const factor = Math.min(1.0, (currentTime - led.fadeStartTime) / led.fadeDuration);
                finalColor = lerpColor(baseColor, [0,0,0], factor);
                led.color = finalColor;
            } else {
                finalColor = baseColor;
            }
            
            const index = i * 4;
            pixels[index] = Math.round(finalColor[0]);
            pixels[index+1] = Math.round(finalColor[1]);
            pixels[index+2] = Math.round(finalColor[2]);
        }
    }
    
    ctx.putImageData(imageData, 0, 0);

    requestAnimationFrame(update);
}

// Initial call
requestAnimationFrame(update);
</script>
</html>
