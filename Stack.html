<!DOCTYPE html><!--Original code: https://gitlab.com/OpenRGBDevelopers/OpenRGBEffectsPlugin/-/tree/master?ref_type=heads-->
<html>
<head>
    <title>ORGB: Stack</title>
    <meta description="Fills and stacks your devices with a solid color.">
    <meta publisher="Jose Miranda (Port and improvements)">

    <meta property="speed" label="Speed" type="number" min="1" max="200" default="50">
    <meta property="direction" label="Matrix Direction" type="list" values="Horizontal,Vertical" default="Horizontal">
    <meta property="random_colors" label="Random Colors" type="boolean" default="false">
    <meta property="user_color" label="Color" type="color" default="#ffffff">
</head>

<body style="margin: 0; padding: 0;">
    <canvas id="stack-canvas" width="320" height="200"></canvas>
</body>

<script>
// -------------------------------------------------------------------
// SETUP
// -------------------------------------------------------------------

const canvas = document.getElementById('stack-canvas');
const ctx = canvas.getContext('2d');
const canvasWidth = canvas.width;
const canvasHeight = canvas.height;
const imageData = ctx.createImageData(canvasWidth, canvasHeight);
const pixels = imageData.data;

// Effect state variables
let progress = 0.0;
let stop_point = 0;
let activeColor = [255, 255, 255];
let lastDirection = direction;
let lastUserColor = user_color;
let lastRandomColors = random_colors;

// -------------------------------------------------------------------
// COLOR UTILITIES
// -------------------------------------------------------------------

function hexToRgb(hex) {
    if (!hex) return [255, 255, 255];
    const r = parseInt(hex.slice(1, 3), 16);
    const g = parseInt(hex.slice(3, 5), 16);
    const b = parseInt(hex.slice(5, 7), 16);
    return [r, g, b];
}

function randomRgb() {
    return [Math.random() * 255, Math.random() * 255, Math.random() * 255];
}

function applyBrightness(rgb, brightness) {
    return [rgb[0] * brightness, rgb[1] * brightness, rgb[2] * brightness];
}

// -------------------------------------------------------------------
// EFFECT LOGIC
// -------------------------------------------------------------------

function resetState(w, h) {
    const size = direction === "Horizontal" ? w : h;
    stop_point = size > 0 ? size - 1 : 0;
    progress = 0.0;
    if (random_colors) {
        activeColor = randomRgb();
    } else {
        activeColor = hexToRgb(user_color);
    }
}

// -------------------------------------------------------------------
// MAIN ANIMATION LOOP
// -------------------------------------------------------------------

let lastTime = 0;

function update(currentTime) {
    const deltaTime = (currentTime - lastTime) / 1000;
    lastTime = currentTime;

    if (isNaN(deltaTime)) {
        requestAnimationFrame(update);
        return;
    }

    // --- Update State ---
    
    // Check if direction or color properties have changed
    if (direction !== lastDirection) {
        resetState(canvasWidth, canvasHeight);
        lastDirection = direction;
    }
    
    if (random_colors !== lastRandomColors || user_color !== lastUserColor) {
        if (random_colors) {
            activeColor = randomRgb();
        } else {
            activeColor = hexToRgb(user_color);
        }
        lastRandomColors = random_colors;
        lastUserColor = user_color;
    }

    const size = direction === "Horizontal" ? canvasWidth : canvasHeight;
    progress += speed * deltaTime;

    if (progress >= 1.0) {
        stop_point -= Math.floor(progress);
        progress %= 1.0;
        
        if (stop_point < 0) {
            resetState(canvasWidth, canvasHeight);
        }
    }

    // --- Render with ImageData ---
    const isHorizontal = direction === "Horizontal";

    for (let i = 0; i < pixels.length; i += 4) {
        pixels[i] = 0;
        pixels[i + 1] = 0;
        pixels[i + 2] = 0;
        pixels[i + 3] = 255;
    }
    
    const movingPos = stop_point - progress;
    const fadeFactor = movingPos - Math.floor(movingPos);
    
    for (let i = 0; i < size; i++) {
        let r, g, b;
        
        if (i > stop_point) {
            r = activeColor[0];
            g = activeColor[1];
            b = activeColor[2];
        } else if (i === Math.floor(movingPos)) {
            const brightness = 1 - fadeFactor;
            const fadedColor = applyBrightness(activeColor, brightness);
            r = fadedColor[0];
            g = fadedColor[1];
            b = fadedColor[2];
        } else if (i === Math.floor(movingPos) + 1) {
            const brightness = fadeFactor;
            const fadedColor = applyBrightness(activeColor, brightness);
            r = fadedColor[0];
            g = fadedColor[1];
            b = fadedColor[2];
        } else {
            continue;
        }

        if (isHorizontal) {
            for (let y = 0; y < canvasHeight; y++) {
                const pixelIndex = (y * canvasWidth + i) * 4;
                pixels[pixelIndex] = r;
                pixels[pixelIndex + 1] = g;
                pixels[pixelIndex + 2] = b;
                pixels[pixelIndex + 3] = 255;
            }
        } else {
            for (let x = 0; x < canvasWidth; x++) {
                const pixelIndex = (i * canvasWidth + x) * 4;
                pixels[pixelIndex] = r;
                pixels[pixelIndex + 1] = g;
                pixels[pixelIndex + 2] = b;
                pixels[pixelIndex + 3] = 255;
            }
        }
    }

    ctx.putImageData(imageData, 0, 0);
    
    requestAnimationFrame(update);
}

// Initial call
resetState(canvasWidth, canvasHeight);
requestAnimationFrame(update);
</script>
</html>