<!DOCTYPE html><!--Original code: https://gitlab.com/OpenRGBDevelopers/OpenRGBEffectsPlugin/-/tree/master?ref_type=heads-->
<html>
<head>
    <title>ORGB: Starry Night</title>
    <meta description="Selects a random LED and fades it in and out.">
    <meta publisher="Jose Miranda (Port and improvements)">

    <meta property="star_density" label="Star Density (%)" type="number" min="10" max="90" default="50">
    <meta property="fade_in_speed" label="Fade In Speed" type="number" min="1" max="100" default="50">
    <meta property="fade_out_speed" label="Fade Out Speed" type="number" min="1" max="100" default="50">
    <meta property="star_on_time" label="Star On Time" type="number" min="1" max="100" default="50">
    
    <meta property="background_color" label="Background Color" type="color" default="#000000">
    <meta property="background_brightness" label="Background Brightness (%)" type="number" min="0" max="100" default="20">

    <meta property="random_colors" label="Random Star Colors" type="boolean" default="true">
    <meta property="color1" label="Star Color 1" type="color" default="#ffffff">
    <meta property="color2" label="Star Color 2" type="color" default="#ffff00">
    <meta property="color3" label="Star Color 3" type="color" default="#00ffff">
</head>

<body style="margin: 0; padding: 0;">
    <canvas id="starrynight-canvas" width="320" height="200"></canvas>
</body>

<script>
// -------------------------------------------------------------------
// SETUP
// -------------------------------------------------------------------

const canvas = document.getElementById('starrynight-canvas');
const ctx = canvas.getContext('2d');
const canvasWidth = canvas.width;
const canvasHeight = canvas.height;
const imageData = ctx.createImageData(canvasWidth, canvasHeight);
const pixels = imageData.data;

let stars = []; // This will store the state for each star

// -------------------------------------------------------------------
// COLOR UTILITIES
// -------------------------------------------------------------------

function hexToRgb(hex) {
    if (!hex) return [255, 255, 255];
    return [parseInt(hex.slice(1, 3), 16), parseInt(hex.slice(3, 5), 16), parseInt(hex.slice(5, 7), 16)];
}

function randomRgb() {
    return [Math.random() * 255, Math.random() * 255, Math.random() * 255];
}

function lerpColor(c1, c2, f) {
    return [
        c1[0] * (1 - f) + c2[0] * f,
        c1[1] * (1 - f) + c2[1] * f,
        c1[2] * (1 - f) + c2[2] * f
    ];
}

function applyBrightness(rgb, brightness) {
    return [rgb[0] * brightness, rgb[1] * brightness, rgb[2] * brightness];
}

function getStarColor() {
    const userColors = [color1, color2, color3].filter(c => c && c !== "#000000");
    if (random_colors) {
        return randomRgb();
    } else if (userColors.length > 0) {
        return hexToRgb(userColors[Math.floor(Math.random() * userColors.length)]);
    }
    return [255, 255, 255]; // Failsafe
}

// -------------------------------------------------------------------
// STAR LOGIC
// -------------------------------------------------------------------

function initializeStars() {
    stars = []; // Clear existing stars
    const totalPixels = canvasWidth * canvasHeight;
    const starCount = Math.floor(totalPixels * (star_density / 100.0));
    
    // Create a new set of stars
    for(let i = 0; i < starCount; i++) {
        stars.push({
            state: "off", // off, fadeIn, on, fadeOut
            pixelIndex: -1,
            color: getStarColor(),
            stateStartTime: 0,
            onDuration: 0,
            fadeDuration: 0
        });
    }
}

// -------------------------------------------------------------------
// MAIN ANIMATION LOOP
// -------------------------------------------------------------------

let lastTime = 0;
let lastDensity = -1;
let lastRandomColors = false;
let lastColor1 = '';
let lastColor2 = '';
let lastColor3 = '';
let lastBackgroundColor = '';
let lastBackgroundBrightness = -1;
let lastFadeInSpeed = -1;
let lastFadeOutSpeed = -1;
let lastStarOnTime = -1;


function update(currentTime) {
    const deltaTime = (currentTime - lastTime); // Milliseconds
    lastTime = currentTime;

    if (isNaN(deltaTime)) {
        requestAnimationFrame(update);
        return;
    }
    
    // If a relevant slider changes, re-initialize the stars array
    if(star_density !== lastDensity || random_colors !== lastRandomColors ||
       color1 !== lastColor1 || color2 !== lastColor2 || color3 !== lastColor3) {
        initializeStars();
        lastDensity = star_density;
        lastRandomColors = random_colors;
        lastColor1 = color1;
        lastColor2 = color2;
        lastColor3 = color3;
    }

    const backgroundRgb = applyBrightness(hexToRgb(background_color), background_brightness/100.0);
    
    // --- Update Star States ---
    const activePixelIndices = new Set(stars.filter(s => s.pixelIndex !== -1).map(s => s.pixelIndex));

    for(const star of stars) {
        if(star.state === "off") {
            // Find a random, unoccupied pixel for this star
            let newPixelIndex;
            let attempts = 0;
            do {
                newPixelIndex = Math.floor(Math.random() * canvasWidth * canvasHeight);
                attempts++;
                if (attempts > 100) break; // Prevent infinite loop on a full canvas
            } while (activePixelIndices.has(newPixelIndex));

            if (attempts <= 100) {
                star.pixelIndex = newPixelIndex;
                activePixelIndices.add(newPixelIndex);
                
                star.state = "fadeIn";
                star.stateStartTime = currentTime;
                star.fadeDuration = 200 + Math.random() * 2000 / (fade_in_speed / 100);
            }
        }
        else if (star.state === "fadeIn") {
            if (currentTime - star.stateStartTime >= star.fadeDuration) {
                star.state = "on";
                star.stateStartTime = currentTime;
                star.onDuration = 100 + Math.random() * 3000 / (star_on_time / 100);
            }
        }
        else if (star.state === "on") {
            if(currentTime - star.stateStartTime >= star.onDuration) {
                star.state = "fadeOut";
                star.stateStartTime = currentTime;
                star.fadeDuration = 200 + Math.random() * 2000 / (fade_out_speed / 100);
            }
        }
        else if (star.state === "fadeOut") {
            if(currentTime - star.stateStartTime >= star.fadeDuration) {
                star.state = "off";
                activePixelIndices.delete(star.pixelIndex); // Free up the pixel
                star.pixelIndex = -1; // Reset pixel index
                star.color = getStarColor(); // Get a new color for the next cycle
            }
        }
    }

    // --- Render ---
    for(let i = 0; i < pixels.length; i += 4) {
        pixels[i] = Math.round(backgroundRgb[0]);
        pixels[i+1] = Math.round(backgroundRgb[1]);
        pixels[i+2] = Math.round(backgroundRgb[2]);
        pixels[i+3] = 255;
    }

    for(const star of stars) {
        if(star.pixelIndex === -1) continue;
        
        let finalColor = backgroundRgb;
        if(star.state === "fadeIn") {
            const factor = (currentTime - star.stateStartTime) / star.fadeDuration;
            finalColor = lerpColor(backgroundRgb, star.color, factor);
        } else if (star.state === "on") {
            finalColor = star.color;
        } else if (star.state === "fadeOut") {
            const factor = 1.0 - (currentTime - star.stateStartTime) / star.fadeDuration;
            finalColor = lerpColor(star.color, backgroundRgb, factor);
        }
        
        const index = star.pixelIndex * 4;
        pixels[index] = Math.round(finalColor[0]);
        pixels[index+1] = Math.round(finalColor[1]);
        pixels[index+2] = Math.round(finalColor[2]);
    }
    
    ctx.putImageData(imageData, 0, 0);

    requestAnimationFrame(update);
}

// Initial call
initializeStars();
requestAnimationFrame(update);
</script>
</html>
