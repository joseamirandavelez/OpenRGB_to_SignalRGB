<!DOCTYPE html>
<html>
<head>
    <title>Starry Night</title>
    <meta description="Selects a random LED and fades it in and out.">
    <meta publisher="Jose Miranda (Conversion and improvements)">

    <meta property="star_density" label="Star Density (%)" type="number" min="10" max="90" default="50">
    <meta property="fade_in_speed" label="Fade In Speed" type="number" min="1" max="100" default="50">
    <meta property="fade_out_speed" label="Fade Out Speed" type="number" min="1" max="100" default="50">
    <meta property="star_on_time" label="Star On Time" type="number" min="1" max="100" default="50">
    
    <meta property="background_color" label="Background Color" type="color" default="#000000">
    <meta property="background_brightness" label="Background Brightness (%)" type="number" min="0" max="100" default="20">

    <meta property="random_colors" label="Random Star Colors" type="boolean" default="true">
    <meta property="color1" label="Star Color 1" type="color" default="#ffffff">
    <meta property="color2" label="Star Color 2" type="color" default="#ffff00">
    <meta property="color3" label="Star Color 3" type="color" default="#00ffff">
</head>

<body style="margin: 0; padding: 0;">
    <canvas id="starrynight-canvas" width="320" height="200"></canvas>
</body>

<script>
// -------------------------------------------------------------------
// SETUP
// -------------------------------------------------------------------

const canvas = document.getElementById('starrynight-canvas');
const ctx = canvas.getContext('2d');
const canvasWidth = canvas.width;
const canvasHeight = canvas.height;

let stars = []; // This will store the state for each star

// Constants for timing ranges (in milliseconds)
const MIN_DELAY = 0, MAX_DELAY = 1000;
const MIN_ON_TIME = 1000, MAX_ON_TIME = 3000;
const MIN_FADE_TIME = 1000, MAX_FADE_TIME = 3000;
const ON_RANGE_SELECTOR = 50.0;
const FADE_RANGE_SELECTOR = 50.0;


// -------------------------------------------------------------------
// COLOR UTILITIES
// -------------------------------------------------------------------

function hexToRgb(hex) {
    if (!hex) return [255, 255, 255];
    return [parseInt(hex.slice(1, 3), 16), parseInt(hex.slice(3, 5), 16), parseInt(hex.slice(5, 7), 16)];
}

function randomRgb() {
    return [Math.random() * 255, Math.random() * 255, Math.random() * 255];
}

function lerpColor(c1, c2, f) {
    return [
        c1[0] * (1 - f) + c2[0] * f,
        c1[1] * (1 - f) + c2[1] * f,
        c1[2] * (1 - f) + c2[2] * f
    ];
}

function applyBrightness(rgb, brightness) {
    return [rgb[0] * brightness, rgb[1] * brightness, rgb[2] * brightness];
}

// -------------------------------------------------------------------
// STAR LOGIC
// -------------------------------------------------------------------

function initializeStars() {
    stars = []; // Clear existing stars
    const totalPixels = canvasWidth * canvasHeight;
    const starCount = Math.floor(totalPixels * (star_density / 100.0));
    
    const userColors = [color1, color2, color3].filter(c => c && c !== "#000000");

    for(let i=0; i < starCount; i++) {
        const star = {
            state: "off", // off, delayed, fadeIn, on, fadeOut
            pixelIndex: -1,
            color: [255,255,255],
            stateStartTime: 0,
            delayDuration: 0,
            onDuration: 0,
            fadeDuration: 0
        };
        // Pre-assign a color
        if (random_colors) {
            star.color = randomRgb();
        } else if (userColors.length > 0) {
            star.color = hexToRgb(userColors[Math.floor(Math.random() * userColors.length)]);
        }
        stars.push(star);
    }
}

// -------------------------------------------------------------------
// MAIN ANIMATION LOOP
// -------------------------------------------------------------------

let lastTime = 0;
let lastDensity = -1;
function update(currentTime) {
    const deltaTime = (currentTime - lastTime); // Milliseconds
    lastTime = currentTime;

    if (isNaN(deltaTime)) {
        requestAnimationFrame(update);
        return;
    }
    
    // If the density slider changes, re-initialize the stars array
    if(star_density !== lastDensity) {
        initializeStars();
        lastDensity = star_density;
    }

    const userColors = [color1, color2, color3].filter(c => c && c !== "#000000");
    const backgroundRgb = applyBrightness(hexToRgb(background_color), background_brightness/100.0);
    
    // --- Update Star States ---
    const activePixelIndices = new Set(stars.map(s => s.pixelIndex));

    for(const star of stars) {
        if(star.state === "off") {
            // Find a random, unoccupied pixel for this star
            let newPixelIndex;
            do {
                newPixelIndex = Math.floor(Math.random() * canvasWidth * canvasHeight);
            } while (activePixelIndices.has(newPixelIndex));

            star.pixelIndex = newPixelIndex;
            activePixelIndices.add(newPixelIndex);
            
            star.state = "delayed";
            star.stateStartTime = currentTime;
            star.delayDuration = MIN_DELAY + Math.random() * (MAX_DELAY - MIN_DELAY);
        }
        else if (star.state === "delayed") {
            if (currentTime - star.stateStartTime >= star.delayDuration) {
                star.state = "fadeIn";
                star.stateStartTime = currentTime;
                star.fadeDuration = (MIN_FADE_TIME + Math.random() * (MAX_FADE_TIME - MIN_FADE_TIME)) * (FADE_RANGE_SELECTOR / fade_in_speed);
            }
        }
        else if (star.state === "fadeIn") {
            if (currentTime - star.stateStartTime >= star.fadeDuration) {
                star.state = "on";
                star.stateStartTime = currentTime;
                star.onDuration = (MIN_ON_TIME + Math.random() * (MAX_ON_TIME - MIN_ON_TIME)) * (ON_RANGE_SELECTOR / star_on_time);
            }
        }
        else if (star.state === "on") {
            if(currentTime - star.stateStartTime >= star.onDuration) {
                star.state = "fadeOut";
                star.stateStartTime = currentTime;
                star.fadeDuration = (MIN_FADE_TIME + Math.random() * (MAX_FADE_TIME - MIN_FADE_TIME)) * (FADE_RANGE_SELECTOR / fade_out_speed);
            }
        }
        else if (star.state === "fadeOut") {
            if(currentTime - star.stateStartTime >= star.fadeDuration) {
                star.state = "off";
                activePixelIndices.delete(star.pixelIndex); // Free up the pixel
                 if (random_colors) {
                    star.color = randomRgb();
                } else if (userColors.length > 0) {
                    star.color = hexToRgb(userColors[Math.floor(Math.random() * userColors.length)]);
                }
            }
        }
    }

    // --- Render ---
    ctx.fillStyle = `rgb(${backgroundRgb[0]}, ${backgroundRgb[1]}, ${backgroundRgb[2]})`;
    ctx.fillRect(0, 0, canvasWidth, canvasHeight);

    const imageData = ctx.getImageData(0,0,canvasWidth, canvasHeight);
    const data = imageData.data;

    for(const star of stars) {
        if(star.pixelIndex === -1) continue;
        
        let finalColor = backgroundRgb;
        if(star.state === "fadeIn") {
            const factor = (currentTime - star.stateStartTime) / star.fadeDuration;
            finalColor = lerpColor(backgroundRgb, star.color, factor);
        } else if (star.state === "on") {
            finalColor = star.color;
        } else if (star.state === "fadeOut") {
            const factor = (currentTime - star.stateStartTime) / star.fadeDuration;
            finalColor = lerpColor(star.color, backgroundRgb, factor);
        }
        
        const index = star.pixelIndex * 4;
        data[index] = finalColor[0];
        data[index+1] = finalColor[1];
        data[index+2] = finalColor[2];
    }
    
    ctx.putImageData(imageData, 0, 0);

    requestAnimationFrame(update);
}

// Initial call
requestAnimationFrame(update);

</script>
</html>