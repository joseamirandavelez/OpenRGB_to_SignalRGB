<!DOCTYPE html>
<html>
<head>
    <title>Swirl Circles</title>
    <meta description="Rotating circles around the center of your devices.">
    <meta publisher="Jose Miranda (Conversion and improvements)">

    <meta property="speed" label="Speed" type="number" min="1" max="100" default="50">
    <meta property="glow" label="Glow" type="number" min="1" max="100" default="50">
    <meta property="radius" label="Radius" type="number" min="0" max="100" default="10">
    <meta property="random_colors" label="Random Colors" type="boolean" default="false">
    <meta property="color1" label="Color 1" type="color" default="#ff0000">
    <meta property="color2" label="Color 2" type="color" default="#0000ff">
</head>

<body style="margin: 0; padding: 0;">
    <canvas id="swirlcircles-canvas" width="320" height="200"></canvas>
</body>

<script>
// -------------------------------------------------------------------
// SETUP
// -------------------------------------------------------------------

const canvas = document.getElementById('swirlcircles-canvas');
const ctx = canvas.getContext('2d');
const canvasWidth = canvas.width;
const canvasHeight = canvas.height;

// Effect state variables
let progress = 0.0;
let hsv1 = { h: 0, s: 1, v: 1 };
let hsv2 = { h: 180, s: 1, v: 1 };
let circle1_pos = { x: 0, y: 0 };
let circle2_pos = { x: 0, y: 0 };

// -------------------------------------------------------------------
// COLOR UTILITIES
// -------------------------------------------------------------------

function hexToHsv(hex) {
    if (!hex) return { h: 0, s: 0, v: 1 };
    let r = parseInt(hex.slice(1, 3), 16) / 255;
    let g = parseInt(hex.slice(3, 5), 16) / 255;
    let b = parseInt(hex.slice(5, 7), 16) / 255;
    let max = Math.max(r, g, b), min = Math.min(r, g, b);
    let h, s, v = max;
    let d = max - min;
    s = max === 0 ? 0 : d / max;
    if (max === min) { h = 0; } 
    else {
        switch (max) {
            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
            case g: h = (b - r) / d + 2; break;
            case b: h = (r - g) / d + 4; break;
        }
        h /= 6;
    }
    return { h: h * 360, s: s, v: v };
}

function hsvToRgb(h, s, v) {
    let r, g, b;
    const i = Math.floor(h * 6); const f = h * 6 - i;
    const p = v * (1 - s); const q = v * (1 - f * s); const t = v * (1 - (1 - f) * s);
    switch (i % 6) {
        case 0: r = v, g = t, b = p; break; case 1: r = q, g = v, b = p; break;
        case 2: r = p, g = v, b = t; break; case 3: r = p, g = q, b = v; break;
        case 4: r = t, g = p, b = v; break; case 5: r = v, g = p, b = q; break;
    }
    return [r * 255, g * 255, b * 255];
}

function screenBlend(c1, c2) {
    return [
        (1 - (1 - c1[0] / 255) * (1 - c2[0] / 255)) * 255,
        (1 - (1 - c1[1] / 255) * (1 - c2[1] / 255)) * 255,
        (1 - (1 - c1[2] / 255) * (1 - c2[2] / 255)) * 255
    ];
}

// -------------------------------------------------------------------
// EFFECT LOGIC
// -------------------------------------------------------------------

function getColor(x, y, w, h) {
    const glow_factor = glow / 100.0;
    
    // --- Circle 1 ---
    const distance1 = Math.sqrt(Math.pow(circle1_pos.x - x, 2) + Math.pow(circle1_pos.y - y, 2));
    const distance1_percent = distance1 < radius ? 0 : Math.pow(distance1 / (h + w), glow_factor);
    const value1 = hsv1.v * (1 - distance1_percent);
    const color1_rgb = hsvToRgb(hsv1.h, hsv1.s, value1);

    // --- Circle 2 ---
    const distance2 = Math.sqrt(Math.pow(circle2_pos.x - x, 2) + Math.pow(circle2_pos.y - y, 2));
    const distance2_percent = distance2 < radius ? 0 : Math.pow(distance2 / (h + w), glow_factor);
    const value2 = hsv2.v * (1 - distance2_percent);
    const color2_rgb = hsvToRgb(hsv2.h, hsv2.s, value2);

    // Blend the two circles together
    const final_color = screenBlend(color1_rgb, color2_rgb);
    
    return `rgb(${final_color[0]}, ${final_color[1]}, ${final_color[2]})`;
}

// -------------------------------------------------------------------
// MAIN ANIMATION LOOP
// -------------------------------------------------------------------

let lastTime = 0;
let lastColor1 = "", lastColor2 = "";
function update(currentTime) {
    const deltaTime = (currentTime - lastTime) / 1000;
    lastTime = currentTime;

    if (isNaN(deltaTime)) {
        requestAnimationFrame(update);
        return;
    }

    progress += 0.1 * speed * deltaTime;

    // Update colors
    if (random_colors) {
        hsv1.h = (hsv1.h + 0.5) % 360;
        hsv2.h = (hsv2.h + 0.5) % 360;
    } else {
        if (color1 !== lastColor1) { hsv1 = hexToHsv(color1); lastColor1 = color1; }
        if (color2 !== lastColor2) { hsv2 = hexToHsv(color2); lastColor2 = color2; }
    }
    
    // Calculate the orbiting positions of the two circles
    const centerX = canvasWidth / 2;
    const centerY = canvasHeight / 2;
    circle1_pos.x = centerX + centerX * Math.cos(progress);
    circle1_pos.y = centerY + centerY * Math.sin(progress);
    circle2_pos.x = canvasWidth - circle1_pos.x;
    circle2_pos.y = canvasHeight - circle1_pos.y;
    
    // --- Render ---
    for (let y = 0; y < canvasHeight; y++) {
        for (let x = 0; x < canvasWidth; x++) {
            ctx.fillStyle = getColor(x, y, canvasWidth, canvasHeight);
            ctx.fillRect(x, y, 1, 1);
        }
    }
    
    requestAnimationFrame(update);
}

// Initial call
requestAnimationFrame(update);

</script>
</html>