<!DOCTYPE html><!--Original code: https://gitlab.com/OpenRGBDevelopers/OpenRGBEffectsPlugin/-/tree/master?ref_type=heads-->
<html>
<head>
    <title>ORGB: Swirl Circles Audio</title>
    <meta description="Rotating circles reacting to audio.">
    <meta publisher="Jose Miranda (Port and improvements)">

    <meta property="speed" label="Speed" type="number" min="1" max="100" default="50">
    <meta property="glow" label="Glow" type="number" min="1" max="100" default="50">
    <meta property="radius" label="Radius" type="number" min="0" max="100" default="10">
    <meta property="random_colors" label="Random Colors" type="boolean" default="false">
    <meta property="color1" label="Color 1" type="color" default="#ff0000">
    <meta property="color2" label="Color 2" type="color" default="#0000ff">
</head>

<body style="margin: 0; padding: 0;">
    <canvas id="swirlcirclesaudio-canvas" width="320" height="200"></canvas>
</body>

<script>
// -------------------------------------------------------------------
// SETUP
// -------------------------------------------------------------------

const canvas = document.getElementById('swirlcirclesaudio-canvas');
const ctx = canvas.getContext('2d');
const canvasWidth = canvas.width;
const canvasHeight = canvas.height;
const imageData = ctx.createImageData(canvasWidth, canvasHeight);
const pixels = imageData.data;

// Effect state variables
let progress = 0.0;
let hsv1 = { h: 0, s: 1, v: 1 };
let hsv2 = { h: 180, s: 1, v: 1 };
let circle1_pos = { x: 0, y: 0 };
let circle2_pos = { x: 0, y: 0 };

// -------------------------------------------------------------------
// COLOR UTILITIES
// -------------------------------------------------------------------

function hexToHsv(hex) {
    if (!hex) return { h: 0, s: 0, v: 1 };
    let r = parseInt(hex.slice(1, 3), 16) / 255;
    let g = parseInt(hex.slice(3, 5), 16) / 255;
    let b = parseInt(hex.slice(5, 7), 16) / 255;
    let max = Math.max(r, g, b), min = Math.min(r, g, b);
    let h, s, v = max;
    let d = max - min;
    s = max === 0 ? 0 : d / max;
    if (max === min) { h = 0; } 
    else {
        switch (max) {
            case r: h = (g - b) / d + (g < b ? 6 : 0); break;
            case g: h = (b - r) / d + 2; break;
            case b: h = (r - g) / d + 4; break;
        }
        h /= 6;
    }
    return { h: h, s: s, v: v };
}

function hsvToRgb(h, s, v) {
    let r, g, b;
    const i = Math.floor(h * 6);
    const f = h * 6 - i;
    const p = v * (1 - s);
    const q = v * (1 - f * s);
    const t = v * (1 - (1 - f) * s);
    switch (i % 6) {
        case 0: r = v, g = t, b = p; break;
        case 1: r = q, g = v, b = p; break;
        case 2: r = p, g = v, b = t; break;
        case 3: r = p, g = q, b = v; break;
        case 4: r = t, g = p, b = v; break;
        case 5: r = v, g = p, b = q; break;
    }
    return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
}

function screenBlend(c1, c2) {
    return [
        255 - (255 - c1[0]) * (255 - c2[0]) / 255,
        255 - (255 - c1[1]) * (255 - c2[1]) / 255,
        255 - (255 - c1[2]) * (255 - c2[2]) / 255
    ];
}

// -------------------------------------------------------------------
// MAIN ANIMATION LOOP
// -------------------------------------------------------------------

let lastTime = 0;
let lastColor1 = "", lastColor2 = "";

function update(currentTime) {
    const deltaTime = (currentTime - lastTime) / 1000;
    lastTime = currentTime;

    if (isNaN(deltaTime) || !engine || !engine.audio || !engine.audio.freq) {
        requestAnimationFrame(update);
        return;
    }
    
    // --- Update State ---
    const audioData = new Int8Array(engine.audio.freq);
    let current_level = 0.0;
    for(let i = 0; i < audioData.length; i++) {
        current_level += Math.abs(audioData[i]) / 128.0;
    }
    current_level = (current_level / audioData.length) * 20;

    progress += 0.1 * speed * deltaTime;

    if (random_colors) {
        hsv1.h = (hsv1.h + 0.005) % 1;
        hsv2.h = (hsv2.h + 0.005) % 1;
    } else {
        if (color1 !== lastColor1) { hsv1 = hexToHsv(color1); lastColor1 = color1; }
        if (color2 !== lastColor2) { hsv2 = hexToHsv(color2); lastColor2 = color2; }
    }
    
    const centerX = canvasWidth / 2;
    const centerY = canvasHeight / 2;
    circle1_pos.x = centerX + (centerX - radius) * Math.cos(progress);
    circle1_pos.y = centerY + (centerY - radius) * Math.sin(progress);
    circle2_pos.x = canvasWidth - circle1_pos.x;
    circle2_pos.y = canvasHeight - circle1_pos.y;
    
    // --- Render with ImageData ---
    const glow_mult = 0.001 * glow;
    
    for (let y = 0; y < canvasHeight; y++) {
        for (let x = 0; x < canvasWidth; x++) {
            const pixelIndex = (y * canvasWidth + x) * 4;

            // --- Circle 1 ---
            const distance1 = Math.sqrt(Math.pow(circle1_pos.x - x, 2) + Math.pow(circle1_pos.y - y, 2));
            const distance1_percent = distance1 < radius ? 0 : Math.pow(distance1 / (canvasHeight + canvasWidth), glow_mult * current_level);
            const value1 = Math.max(0, hsv1.v * (1 - distance1_percent));
            const color1_rgb = hsvToRgb(hsv1.h, hsv1.s, value1);

            // --- Circle 2 ---
            const distance2 = Math.sqrt(Math.pow(circle2_pos.x - x, 2) + Math.pow(circle2_pos.y - y, 2));
            const distance2_percent = distance2 < radius ? 0 : Math.pow(distance2 / (canvasHeight + canvasWidth), glow_mult * current_level);
            const value2 = Math.max(0, hsv2.v * (1 - distance2_percent));
            const color2_rgb = hsvToRgb(hsv2.h, hsv2.s, value2);

            // Blend the two circles together
            const final_color = screenBlend(color1_rgb, color2_rgb);

            pixels[pixelIndex] = final_color[0];
            pixels[pixelIndex + 1] = final_color[1];
            pixels[pixelIndex + 2] = final_color[2];
            pixels[pixelIndex + 3] = 255;
        }
    }
    
    ctx.putImageData(imageData, 0, 0);
    
    requestAnimationFrame(update);
}

// Initial call
requestAnimationFrame(update);
</script>
</html>