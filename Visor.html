<!DOCTYPE html>
<html>
<head>
    <title>Visor</title>
    <meta description="A back and forth effect motion, flipping colors.">
    <meta publisher="Jose Miranda (Conversion and improvements)">

    <meta property="speed" label="Speed" type="number" min="1" max="100" default="50">
    <meta property="width" label="Width" type="number" min="1" max="100" default="20">
    <meta property="random_colors" label="Random Colors" type="boolean" default="false">
    <meta property="color1" label="Color 1" type="color" default="#ff0000">
    <meta property="color2" label="Color 2" type="color" default="#000000">
</head>

<body style="margin: 0; padding: 0;">
    <canvas id="visor-canvas" width="320" height="200"></canvas>
</body>

<script>
// -------------------------------------------------------------------
// SETUP
// -------------------------------------------------------------------

const canvas = document.getElementById('visor-canvas');
const ctx = canvas.getContext('2d');
const canvasWidth = canvas.width;
const canvasHeight = canvas.height;

// Effect state variables
let progress = 0.0;
let last_step = false;
let color_a = [255, 0, 0];
let color_b = [0, 0, 0];

// -------------------------------------------------------------------
// COLOR UTILITIES
// -------------------------------------------------------------------

function hexToRgb(hex) {
    if (!hex) return [0, 0, 0];
    const r = parseInt(hex.slice(1, 3), 16);
    const g = parseInt(hex.slice(3, 5), 16);
    const b = parseInt(hex.slice(5, 7), 16);
    return [r, g, b];
}

function randomRgb() {
    return [Math.random() * 255, Math.random() * 255, Math.random() * 255];
}

function applyBrightness(rgb, brightness) {
    return [rgb[0] * brightness, rgb[1] * brightness, rgb[2] * brightness];
}

/** Linearly interpolates between two colors */
function lerpColor(c1, c2, factor) {
    const r = c1[0] * (1 - factor) + c2[0] * factor;
    const g = c1[1] * (1 - factor) + c2[1] * factor;
    const b = c1[2] * (1 - factor) + c2[2] * factor;
    return [r, g, b];
}

// -------------------------------------------------------------------
// EFFECT LOGIC
// -------------------------------------------------------------------

function getColor(x, w, p_step, step) {
    const visor_width = Math.max(1.5 / w, width / 100.0);
    const x_step = p_step * (1.0 + 4.0 * visor_width) - 1.5 * visor_width;
    const x_norm = x / (w - 1);
    const dist = x_step - x_norm;

    // Fade the head of the visor
    if (dist < 0) {
        const brightness = Math.max(0.0, Math.min(1.0, (visor_width + dist) / visor_width));
        return step ? applyBrightness(color_b, brightness) : applyBrightness(color_a, brightness);
    }

    // Fade the tail of the visor
    if (dist > visor_width) {
        const brightness = Math.max(0.0, Math.min(1.0, 1.0 - ((dist - visor_width) / visor_width)));
        return step ? applyBrightness(color_a, brightness) : applyBrightness(color_b, brightness);
    }
    
    // Interpolate colors within the main body of the visor
    const factor = Math.min(1.0, Math.max(0.0, (visor_width - dist) / visor_width));
    const finalColor = step ? lerpColor(color_a, color_b, factor) : lerpColor(color_b, color_a, factor);
    
    return `rgb(${finalColor[0]}, ${finalColor[1]}, ${finalColor[2]})`;
}

// -------------------------------------------------------------------
// MAIN ANIMATION LOOP
// -------------------------------------------------------------------

let lastTime = 0;
function update(currentTime) {
    const deltaTime = (currentTime - lastTime) / 1000;
    lastTime = currentTime;

    if (isNaN(deltaTime)) {
        requestAnimationFrame(update);
        return;
    }

    // --- Update State ---
    progress += 0.01 * speed * deltaTime * 60;

    const p = progress % 1.0;
    const step = p < 0.5; // true for left-to-right, false for right-to-left
    const p_step = step ? 2.0 * p : 2.0 * (1.0 - p);
    
    const is_flipping = (last_step !== step);

    if (is_flipping) {
        last_step = step;
        if (random_colors) {
            color_a = randomRgb();
            color_b = randomRgb();
        }
    }
    
    if (!random_colors) {
        color_a = hexToRgb(color1);
        color_b = hexToRgb(color2);
    }

    // --- Render ---
    for (let x = 0; x < canvasWidth; x++) {
        const rgb = getColor(x, canvasWidth, p_step, step);
        if (typeof rgb === 'string') { // getColor can return a string
            ctx.fillStyle = rgb;
        } else { // Or an array
            ctx.fillStyle = `rgb(${rgb[0]}, ${rgb[1]}, ${rgb[2]})`;
        }
        ctx.fillRect(x, 0, 1, canvasHeight);
    }
    
    requestAnimationFrame(update);
}

// Initial call
requestAnimationFrame(update);

</script>
</html>