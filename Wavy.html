<!DOCTYPE html>
<html>
<head>
    <title>Wavy</title>
    <meta description="Alternate colors like waves.">
    <meta publisher="Jose Miranda (Conversion and improvements)">

    <meta property="wave_frequency" label="Wave Frequency" type="number" min="1" max="20" default="5">
    <meta property="wave_speed" label="Wave Speed" type="number" min="1" max="200" default="50">
    <meta property="oscillation_speed" label="Oscillation Speed" type="number" min="1" max="200" default="100">
    <meta property="random_colors" label="Random Colors" type="boolean" default="false">
    <meta property="color1" label="Color 1" type="color" default="#ff0000">
    <meta property="color2" label="Color 2" type="color" default="#0000ff">
</head>

<body style="margin: 0; padding: 0;">
    <canvas id="wavy-canvas" width="320" height="200"></canvas>
</body>

<script>
// -------------------------------------------------------------------
// SETUP
// -------------------------------------------------------------------

const canvas = document.getElementById('wavy-canvas');
const ctx = canvas.getContext('2d');
const canvasWidth = canvas.width;
const canvasHeight = canvas.height;

// Effect state variables
let direction = true; // true = up, false = down
let sine_progress = 0.0; // Controls the color oscillation (-1 to 1)
let wave_progress = 0.0; // Controls the horizontal scroll (0 to 100)
let color_a = [255, 0, 0];
let color_b = [0, 0, 255];

// -------------------------------------------------------------------
// COLOR UTILITIES
// -------------------------------------------------------------------

function hexToRgb(hex) {
    if (!hex) return [0, 0, 0];
    const r = parseInt(hex.slice(1, 3), 16);
    const g = parseInt(hex.slice(3, 5), 16);
    const b = parseInt(hex.slice(5, 7), 16);
    return [r, g, b];
}

function randomRgb() {
    return [Math.random() * 255, Math.random() * 255, Math.random() * 255];
}

/** Inverts a color */
function invertRgb(rgb) {
    return [255 - rgb[0], 255 - rgb[1], 255 - rgb[2]];
}

/** Linearly interpolates between two colors */
function lerpColor(c1, c2, factor) {
    const r = c1[0] * (1 - factor) + c2[0] * factor;
    const g = c1[1] * (1 - factor) + c2[1] * factor;
    const b = c1[2] * (1 - factor) + c2[2] * factor;
    return [r, g, b];
}

// -------------------------------------------------------------------
// EFFECT LOGIC
// -------------------------------------------------------------------

function getColor(x, w) {
    // Calculate the position of the pixel within the scrolling wave
    const pos = (x + (w * wave_progress) / 100.0) / w;
    const rad = (360.0 * pos) * Math.PI / 180.0;
    
    // Calculate the height of the sine wave at this position
    const wave_height = sine_progress * Math.sin(wave_frequency * rad);
    
    // Normalize the height to a 0.0 - 1.0 factor for color interpolation
    const h_factor = 0.5 + wave_height / 2.0;
    
    const final_color = lerpColor(color_a, color_b, h_factor);
    
    return `rgb(${final_color[0]}, ${final_color[1]}, ${final_color[2]})`;
}

// -------------------------------------------------------------------
// MAIN ANIMATION LOOP
// -------------------------------------------------------------------

let lastTime = 0;
function update(currentTime) {
    const deltaTime = (currentTime - lastTime) / 1000;
    lastTime = currentTime;

    if (isNaN(deltaTime)) {
        requestAnimationFrame(update);
        return;
    }

    // --- Update State ---

    // Update the color oscillation progress (moves between -1 and 1)
    const osc_delta = 0.01 * oscillation_speed * deltaTime * 60;
    if (direction) {
        sine_progress += osc_delta;
        if (sine_progress >= 1.0) direction = false;
    } else {
        sine_progress -= osc_delta;
        if (sine_progress <= -1.0) direction = true;
    }
    sine_progress = Math.max(-1.0, Math.min(1.0, sine_progress));
    
    // Update the horizontal scrolling progress
    wave_progress += 0.05 * wave_speed * deltaTime * 60;
    if (wave_progress >= 100.0) wave_progress = 0.0;
    
    // Check if a cycle has just completed to generate new random colors
    if (Math.abs(sine_progress) < 0.01) {
        if (random_colors) {
            color_a = randomRgb();
            color_b = invertRgb(color_a);
        }
    }
    if (!random_colors) {
        color_a = hexToRgb(color1);
        color_b = hexToRgb(color2);
    }
    
    // --- Render ---
    // This is a horizontal effect, so we calculate each column's color once
    for (let x = 0; x < canvasWidth; x++) {
        const colColor = getColor(x, canvasWidth);
        ctx.fillStyle = colColor;
        ctx.fillRect(x, 0, 1, canvasHeight);
    }
    
    requestAnimationFrame(update);
}

// Initial call
requestAnimationFrame(update);

</script>
</html>